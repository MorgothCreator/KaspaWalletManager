// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kaspawalletd.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kaspawalletd_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kaspawalletd_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kaspawalletd_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kaspawalletd_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kaspawalletd_2eproto;
namespace kaspawalletd {
class AddressBalances;
struct AddressBalancesDefaultTypeInternal;
extern AddressBalancesDefaultTypeInternal _AddressBalances_default_instance_;
class BroadcastRequest;
struct BroadcastRequestDefaultTypeInternal;
extern BroadcastRequestDefaultTypeInternal _BroadcastRequest_default_instance_;
class BroadcastResponse;
struct BroadcastResponseDefaultTypeInternal;
extern BroadcastResponseDefaultTypeInternal _BroadcastResponse_default_instance_;
class CheckIfAddressIsValidRequest;
struct CheckIfAddressIsValidRequestDefaultTypeInternal;
extern CheckIfAddressIsValidRequestDefaultTypeInternal _CheckIfAddressIsValidRequest_default_instance_;
class CheckIfAddressIsValidResponse;
struct CheckIfAddressIsValidResponseDefaultTypeInternal;
extern CheckIfAddressIsValidResponseDefaultTypeInternal _CheckIfAddressIsValidResponse_default_instance_;
class CheckIfAddressesAreValidRequest;
struct CheckIfAddressesAreValidRequestDefaultTypeInternal;
extern CheckIfAddressesAreValidRequestDefaultTypeInternal _CheckIfAddressesAreValidRequest_default_instance_;
class CheckIfAddressesAreValidResponse;
struct CheckIfAddressesAreValidResponseDefaultTypeInternal;
extern CheckIfAddressesAreValidResponseDefaultTypeInternal _CheckIfAddressesAreValidResponse_default_instance_;
class CreateUnsignedTransactionsRequest;
struct CreateUnsignedTransactionsRequestDefaultTypeInternal;
extern CreateUnsignedTransactionsRequestDefaultTypeInternal _CreateUnsignedTransactionsRequest_default_instance_;
class CreateUnsignedTransactionsResponse;
struct CreateUnsignedTransactionsResponseDefaultTypeInternal;
extern CreateUnsignedTransactionsResponseDefaultTypeInternal _CreateUnsignedTransactionsResponse_default_instance_;
class GetBalanceRequest;
struct GetBalanceRequestDefaultTypeInternal;
extern GetBalanceRequestDefaultTypeInternal _GetBalanceRequest_default_instance_;
class GetBalanceResponse;
struct GetBalanceResponseDefaultTypeInternal;
extern GetBalanceResponseDefaultTypeInternal _GetBalanceResponse_default_instance_;
class GetExternalSpendableUTXOsRequest;
struct GetExternalSpendableUTXOsRequestDefaultTypeInternal;
extern GetExternalSpendableUTXOsRequestDefaultTypeInternal _GetExternalSpendableUTXOsRequest_default_instance_;
class GetExternalSpendableUTXOsResponse;
struct GetExternalSpendableUTXOsResponseDefaultTypeInternal;
extern GetExternalSpendableUTXOsResponseDefaultTypeInternal _GetExternalSpendableUTXOsResponse_default_instance_;
class IsValidAddress;
struct IsValidAddressDefaultTypeInternal;
extern IsValidAddressDefaultTypeInternal _IsValidAddress_default_instance_;
class NewAddressRequest;
struct NewAddressRequestDefaultTypeInternal;
extern NewAddressRequestDefaultTypeInternal _NewAddressRequest_default_instance_;
class NewAddressResponse;
struct NewAddressResponseDefaultTypeInternal;
extern NewAddressResponseDefaultTypeInternal _NewAddressResponse_default_instance_;
class Outpoint;
struct OutpointDefaultTypeInternal;
extern OutpointDefaultTypeInternal _Outpoint_default_instance_;
class ScriptPublicKey;
struct ScriptPublicKeyDefaultTypeInternal;
extern ScriptPublicKeyDefaultTypeInternal _ScriptPublicKey_default_instance_;
class SendRequest;
struct SendRequestDefaultTypeInternal;
extern SendRequestDefaultTypeInternal _SendRequest_default_instance_;
class SendResponse;
struct SendResponseDefaultTypeInternal;
extern SendResponseDefaultTypeInternal _SendResponse_default_instance_;
class ShowAddressesRequest;
struct ShowAddressesRequestDefaultTypeInternal;
extern ShowAddressesRequestDefaultTypeInternal _ShowAddressesRequest_default_instance_;
class ShowAddressesResponse;
struct ShowAddressesResponseDefaultTypeInternal;
extern ShowAddressesResponseDefaultTypeInternal _ShowAddressesResponse_default_instance_;
class ShutdownRequest;
struct ShutdownRequestDefaultTypeInternal;
extern ShutdownRequestDefaultTypeInternal _ShutdownRequest_default_instance_;
class ShutdownResponse;
struct ShutdownResponseDefaultTypeInternal;
extern ShutdownResponseDefaultTypeInternal _ShutdownResponse_default_instance_;
class SignRequest;
struct SignRequestDefaultTypeInternal;
extern SignRequestDefaultTypeInternal _SignRequest_default_instance_;
class SignResponse;
struct SignResponseDefaultTypeInternal;
extern SignResponseDefaultTypeInternal _SignResponse_default_instance_;
class UtxoEntry;
struct UtxoEntryDefaultTypeInternal;
extern UtxoEntryDefaultTypeInternal _UtxoEntry_default_instance_;
class UtxosByAddressesEntry;
struct UtxosByAddressesEntryDefaultTypeInternal;
extern UtxosByAddressesEntryDefaultTypeInternal _UtxosByAddressesEntry_default_instance_;
}  // namespace kaspawalletd
PROTOBUF_NAMESPACE_OPEN
template<> ::kaspawalletd::AddressBalances* Arena::CreateMaybeMessage<::kaspawalletd::AddressBalances>(Arena*);
template<> ::kaspawalletd::BroadcastRequest* Arena::CreateMaybeMessage<::kaspawalletd::BroadcastRequest>(Arena*);
template<> ::kaspawalletd::BroadcastResponse* Arena::CreateMaybeMessage<::kaspawalletd::BroadcastResponse>(Arena*);
template<> ::kaspawalletd::CheckIfAddressIsValidRequest* Arena::CreateMaybeMessage<::kaspawalletd::CheckIfAddressIsValidRequest>(Arena*);
template<> ::kaspawalletd::CheckIfAddressIsValidResponse* Arena::CreateMaybeMessage<::kaspawalletd::CheckIfAddressIsValidResponse>(Arena*);
template<> ::kaspawalletd::CheckIfAddressesAreValidRequest* Arena::CreateMaybeMessage<::kaspawalletd::CheckIfAddressesAreValidRequest>(Arena*);
template<> ::kaspawalletd::CheckIfAddressesAreValidResponse* Arena::CreateMaybeMessage<::kaspawalletd::CheckIfAddressesAreValidResponse>(Arena*);
template<> ::kaspawalletd::CreateUnsignedTransactionsRequest* Arena::CreateMaybeMessage<::kaspawalletd::CreateUnsignedTransactionsRequest>(Arena*);
template<> ::kaspawalletd::CreateUnsignedTransactionsResponse* Arena::CreateMaybeMessage<::kaspawalletd::CreateUnsignedTransactionsResponse>(Arena*);
template<> ::kaspawalletd::GetBalanceRequest* Arena::CreateMaybeMessage<::kaspawalletd::GetBalanceRequest>(Arena*);
template<> ::kaspawalletd::GetBalanceResponse* Arena::CreateMaybeMessage<::kaspawalletd::GetBalanceResponse>(Arena*);
template<> ::kaspawalletd::GetExternalSpendableUTXOsRequest* Arena::CreateMaybeMessage<::kaspawalletd::GetExternalSpendableUTXOsRequest>(Arena*);
template<> ::kaspawalletd::GetExternalSpendableUTXOsResponse* Arena::CreateMaybeMessage<::kaspawalletd::GetExternalSpendableUTXOsResponse>(Arena*);
template<> ::kaspawalletd::IsValidAddress* Arena::CreateMaybeMessage<::kaspawalletd::IsValidAddress>(Arena*);
template<> ::kaspawalletd::NewAddressRequest* Arena::CreateMaybeMessage<::kaspawalletd::NewAddressRequest>(Arena*);
template<> ::kaspawalletd::NewAddressResponse* Arena::CreateMaybeMessage<::kaspawalletd::NewAddressResponse>(Arena*);
template<> ::kaspawalletd::Outpoint* Arena::CreateMaybeMessage<::kaspawalletd::Outpoint>(Arena*);
template<> ::kaspawalletd::ScriptPublicKey* Arena::CreateMaybeMessage<::kaspawalletd::ScriptPublicKey>(Arena*);
template<> ::kaspawalletd::SendRequest* Arena::CreateMaybeMessage<::kaspawalletd::SendRequest>(Arena*);
template<> ::kaspawalletd::SendResponse* Arena::CreateMaybeMessage<::kaspawalletd::SendResponse>(Arena*);
template<> ::kaspawalletd::ShowAddressesRequest* Arena::CreateMaybeMessage<::kaspawalletd::ShowAddressesRequest>(Arena*);
template<> ::kaspawalletd::ShowAddressesResponse* Arena::CreateMaybeMessage<::kaspawalletd::ShowAddressesResponse>(Arena*);
template<> ::kaspawalletd::ShutdownRequest* Arena::CreateMaybeMessage<::kaspawalletd::ShutdownRequest>(Arena*);
template<> ::kaspawalletd::ShutdownResponse* Arena::CreateMaybeMessage<::kaspawalletd::ShutdownResponse>(Arena*);
template<> ::kaspawalletd::SignRequest* Arena::CreateMaybeMessage<::kaspawalletd::SignRequest>(Arena*);
template<> ::kaspawalletd::SignResponse* Arena::CreateMaybeMessage<::kaspawalletd::SignResponse>(Arena*);
template<> ::kaspawalletd::UtxoEntry* Arena::CreateMaybeMessage<::kaspawalletd::UtxoEntry>(Arena*);
template<> ::kaspawalletd::UtxosByAddressesEntry* Arena::CreateMaybeMessage<::kaspawalletd::UtxosByAddressesEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kaspawalletd {

// ===================================================================

class GetBalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kaspawalletd.GetBalanceRequest) */ {
 public:
  inline GetBalanceRequest() : GetBalanceRequest(nullptr) {}
  explicit constexpr GetBalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBalanceRequest(const GetBalanceRequest& from);
  GetBalanceRequest(GetBalanceRequest&& from) noexcept
    : GetBalanceRequest() {
    *this = ::std::move(from);
  }

  inline GetBalanceRequest& operator=(const GetBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBalanceRequest& operator=(GetBalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetBalanceRequest*>(
               &_GetBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetBalanceRequest& a, GetBalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBalanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBalanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBalanceRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBalanceRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.GetBalanceRequest";
  }
  protected:
  explicit GetBalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kaspawalletd.GetBalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.GetBalanceResponse) */ {
 public:
  inline GetBalanceResponse() : GetBalanceResponse(nullptr) {}
  ~GetBalanceResponse() override;
  explicit constexpr GetBalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBalanceResponse(const GetBalanceResponse& from);
  GetBalanceResponse(GetBalanceResponse&& from) noexcept
    : GetBalanceResponse() {
    *this = ::std::move(from);
  }

  inline GetBalanceResponse& operator=(const GetBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBalanceResponse& operator=(GetBalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const GetBalanceResponse*>(
               &_GetBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetBalanceResponse& a, GetBalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBalanceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBalanceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBalanceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBalanceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.GetBalanceResponse";
  }
  protected:
  explicit GetBalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressBalancesFieldNumber = 3,
    kAvailableFieldNumber = 1,
    kPendingFieldNumber = 2,
  };
  // repeated .kaspawalletd.AddressBalances addressBalances = 3;
  int addressbalances_size() const;
  private:
  int _internal_addressbalances_size() const;
  public:
  void clear_addressbalances();
  ::kaspawalletd::AddressBalances* mutable_addressbalances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::AddressBalances >*
      mutable_addressbalances();
  private:
  const ::kaspawalletd::AddressBalances& _internal_addressbalances(int index) const;
  ::kaspawalletd::AddressBalances* _internal_add_addressbalances();
  public:
  const ::kaspawalletd::AddressBalances& addressbalances(int index) const;
  ::kaspawalletd::AddressBalances* add_addressbalances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::AddressBalances >&
      addressbalances() const;

  // uint64 available = 1;
  void clear_available();
  uint64_t available() const;
  void set_available(uint64_t value);
  private:
  uint64_t _internal_available() const;
  void _internal_set_available(uint64_t value);
  public:

  // uint64 pending = 2;
  void clear_pending();
  uint64_t pending() const;
  void set_pending(uint64_t value);
  private:
  uint64_t _internal_pending() const;
  void _internal_set_pending(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.GetBalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::AddressBalances > addressbalances_;
  uint64_t available_;
  uint64_t pending_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class AddressBalances final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.AddressBalances) */ {
 public:
  inline AddressBalances() : AddressBalances(nullptr) {}
  ~AddressBalances() override;
  explicit constexpr AddressBalances(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressBalances(const AddressBalances& from);
  AddressBalances(AddressBalances&& from) noexcept
    : AddressBalances() {
    *this = ::std::move(from);
  }

  inline AddressBalances& operator=(const AddressBalances& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressBalances& operator=(AddressBalances&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressBalances& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressBalances* internal_default_instance() {
    return reinterpret_cast<const AddressBalances*>(
               &_AddressBalances_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AddressBalances& a, AddressBalances& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressBalances* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressBalances* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddressBalances* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddressBalances>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressBalances& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressBalances& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressBalances* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.AddressBalances";
  }
  protected:
  explicit AddressBalances(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kAvailableFieldNumber = 2,
    kPendingFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 available = 2;
  void clear_available();
  uint64_t available() const;
  void set_available(uint64_t value);
  private:
  uint64_t _internal_available() const;
  void _internal_set_available(uint64_t value);
  public:

  // uint64 pending = 3;
  void clear_pending();
  uint64_t pending() const;
  void set_pending(uint64_t value);
  private:
  uint64_t _internal_pending() const;
  void _internal_set_pending(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.AddressBalances)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  uint64_t available_;
  uint64_t pending_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class CreateUnsignedTransactionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.CreateUnsignedTransactionsRequest) */ {
 public:
  inline CreateUnsignedTransactionsRequest() : CreateUnsignedTransactionsRequest(nullptr) {}
  ~CreateUnsignedTransactionsRequest() override;
  explicit constexpr CreateUnsignedTransactionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateUnsignedTransactionsRequest(const CreateUnsignedTransactionsRequest& from);
  CreateUnsignedTransactionsRequest(CreateUnsignedTransactionsRequest&& from) noexcept
    : CreateUnsignedTransactionsRequest() {
    *this = ::std::move(from);
  }

  inline CreateUnsignedTransactionsRequest& operator=(const CreateUnsignedTransactionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUnsignedTransactionsRequest& operator=(CreateUnsignedTransactionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUnsignedTransactionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUnsignedTransactionsRequest* internal_default_instance() {
    return reinterpret_cast<const CreateUnsignedTransactionsRequest*>(
               &_CreateUnsignedTransactionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateUnsignedTransactionsRequest& a, CreateUnsignedTransactionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUnsignedTransactionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUnsignedTransactionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUnsignedTransactionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateUnsignedTransactionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateUnsignedTransactionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateUnsignedTransactionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUnsignedTransactionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.CreateUnsignedTransactionsRequest";
  }
  protected:
  explicit CreateUnsignedTransactionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 3,
    kAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // repeated string from = 3;
  int from_size() const;
  private:
  int _internal_from_size() const;
  public:
  void clear_from();
  const std::string& from(int index) const;
  std::string* mutable_from(int index);
  void set_from(int index, const std::string& value);
  void set_from(int index, std::string&& value);
  void set_from(int index, const char* value);
  void set_from(int index, const char* value, size_t size);
  std::string* add_from();
  void add_from(const std::string& value);
  void add_from(std::string&& value);
  void add_from(const char* value);
  void add_from(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& from() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_from();
  private:
  const std::string& _internal_from(int index) const;
  std::string* _internal_add_from();
  public:

  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.CreateUnsignedTransactionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class CreateUnsignedTransactionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.CreateUnsignedTransactionsResponse) */ {
 public:
  inline CreateUnsignedTransactionsResponse() : CreateUnsignedTransactionsResponse(nullptr) {}
  ~CreateUnsignedTransactionsResponse() override;
  explicit constexpr CreateUnsignedTransactionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateUnsignedTransactionsResponse(const CreateUnsignedTransactionsResponse& from);
  CreateUnsignedTransactionsResponse(CreateUnsignedTransactionsResponse&& from) noexcept
    : CreateUnsignedTransactionsResponse() {
    *this = ::std::move(from);
  }

  inline CreateUnsignedTransactionsResponse& operator=(const CreateUnsignedTransactionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUnsignedTransactionsResponse& operator=(CreateUnsignedTransactionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUnsignedTransactionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUnsignedTransactionsResponse* internal_default_instance() {
    return reinterpret_cast<const CreateUnsignedTransactionsResponse*>(
               &_CreateUnsignedTransactionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateUnsignedTransactionsResponse& a, CreateUnsignedTransactionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUnsignedTransactionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUnsignedTransactionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUnsignedTransactionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateUnsignedTransactionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateUnsignedTransactionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateUnsignedTransactionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUnsignedTransactionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.CreateUnsignedTransactionsResponse";
  }
  protected:
  explicit CreateUnsignedTransactionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnsignedTransactionsFieldNumber = 1,
  };
  // repeated bytes unsignedTransactions = 1;
  int unsignedtransactions_size() const;
  private:
  int _internal_unsignedtransactions_size() const;
  public:
  void clear_unsignedtransactions();
  const std::string& unsignedtransactions(int index) const;
  std::string* mutable_unsignedtransactions(int index);
  void set_unsignedtransactions(int index, const std::string& value);
  void set_unsignedtransactions(int index, std::string&& value);
  void set_unsignedtransactions(int index, const char* value);
  void set_unsignedtransactions(int index, const void* value, size_t size);
  std::string* add_unsignedtransactions();
  void add_unsignedtransactions(const std::string& value);
  void add_unsignedtransactions(std::string&& value);
  void add_unsignedtransactions(const char* value);
  void add_unsignedtransactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unsignedtransactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unsignedtransactions();
  private:
  const std::string& _internal_unsignedtransactions(int index) const;
  std::string* _internal_add_unsignedtransactions();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.CreateUnsignedTransactionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unsignedtransactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class ShowAddressesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kaspawalletd.ShowAddressesRequest) */ {
 public:
  inline ShowAddressesRequest() : ShowAddressesRequest(nullptr) {}
  explicit constexpr ShowAddressesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowAddressesRequest(const ShowAddressesRequest& from);
  ShowAddressesRequest(ShowAddressesRequest&& from) noexcept
    : ShowAddressesRequest() {
    *this = ::std::move(from);
  }

  inline ShowAddressesRequest& operator=(const ShowAddressesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowAddressesRequest& operator=(ShowAddressesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowAddressesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowAddressesRequest* internal_default_instance() {
    return reinterpret_cast<const ShowAddressesRequest*>(
               &_ShowAddressesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShowAddressesRequest& a, ShowAddressesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowAddressesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowAddressesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowAddressesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowAddressesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShowAddressesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShowAddressesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.ShowAddressesRequest";
  }
  protected:
  explicit ShowAddressesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kaspawalletd.ShowAddressesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class ShowAddressesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.ShowAddressesResponse) */ {
 public:
  inline ShowAddressesResponse() : ShowAddressesResponse(nullptr) {}
  ~ShowAddressesResponse() override;
  explicit constexpr ShowAddressesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowAddressesResponse(const ShowAddressesResponse& from);
  ShowAddressesResponse(ShowAddressesResponse&& from) noexcept
    : ShowAddressesResponse() {
    *this = ::std::move(from);
  }

  inline ShowAddressesResponse& operator=(const ShowAddressesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowAddressesResponse& operator=(ShowAddressesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowAddressesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowAddressesResponse* internal_default_instance() {
    return reinterpret_cast<const ShowAddressesResponse*>(
               &_ShowAddressesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ShowAddressesResponse& a, ShowAddressesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowAddressesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowAddressesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowAddressesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowAddressesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowAddressesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowAddressesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowAddressesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.ShowAddressesResponse";
  }
  protected:
  explicit ShowAddressesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // repeated string address = 1;
  int address_size() const;
  private:
  int _internal_address_size() const;
  public:
  void clear_address();
  const std::string& address(int index) const;
  std::string* mutable_address(int index);
  void set_address(int index, const std::string& value);
  void set_address(int index, std::string&& value);
  void set_address(int index, const char* value);
  void set_address(int index, const char* value, size_t size);
  std::string* add_address();
  void add_address(const std::string& value);
  void add_address(std::string&& value);
  void add_address(const char* value);
  void add_address(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& address() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_address();
  private:
  const std::string& _internal_address(int index) const;
  std::string* _internal_add_address();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.ShowAddressesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class NewAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kaspawalletd.NewAddressRequest) */ {
 public:
  inline NewAddressRequest() : NewAddressRequest(nullptr) {}
  explicit constexpr NewAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAddressRequest(const NewAddressRequest& from);
  NewAddressRequest(NewAddressRequest&& from) noexcept
    : NewAddressRequest() {
    *this = ::std::move(from);
  }

  inline NewAddressRequest& operator=(const NewAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAddressRequest& operator=(NewAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAddressRequest* internal_default_instance() {
    return reinterpret_cast<const NewAddressRequest*>(
               &_NewAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NewAddressRequest& a, NewAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NewAddressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NewAddressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.NewAddressRequest";
  }
  protected:
  explicit NewAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kaspawalletd.NewAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class NewAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.NewAddressResponse) */ {
 public:
  inline NewAddressResponse() : NewAddressResponse(nullptr) {}
  ~NewAddressResponse() override;
  explicit constexpr NewAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAddressResponse(const NewAddressResponse& from);
  NewAddressResponse(NewAddressResponse&& from) noexcept
    : NewAddressResponse() {
    *this = ::std::move(from);
  }

  inline NewAddressResponse& operator=(const NewAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAddressResponse& operator=(NewAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAddressResponse* internal_default_instance() {
    return reinterpret_cast<const NewAddressResponse*>(
               &_NewAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NewAddressResponse& a, NewAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAddressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewAddressResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.NewAddressResponse";
  }
  protected:
  explicit NewAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.NewAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class BroadcastRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.BroadcastRequest) */ {
 public:
  inline BroadcastRequest() : BroadcastRequest(nullptr) {}
  ~BroadcastRequest() override;
  explicit constexpr BroadcastRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastRequest(const BroadcastRequest& from);
  BroadcastRequest(BroadcastRequest&& from) noexcept
    : BroadcastRequest() {
    *this = ::std::move(from);
  }

  inline BroadcastRequest& operator=(const BroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastRequest& operator=(BroadcastRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastRequest* internal_default_instance() {
    return reinterpret_cast<const BroadcastRequest*>(
               &_BroadcastRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BroadcastRequest& a, BroadcastRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BroadcastRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.BroadcastRequest";
  }
  protected:
  explicit BroadcastRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 2,
    kIsDomainFieldNumber = 1,
  };
  // repeated bytes transactions = 2;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, size_t size);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions();
  private:
  const std::string& _internal_transactions(int index) const;
  std::string* _internal_add_transactions();
  public:

  // bool isDomain = 1;
  void clear_isdomain();
  bool isdomain() const;
  void set_isdomain(bool value);
  private:
  bool _internal_isdomain() const;
  void _internal_set_isdomain(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.BroadcastRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_;
  bool isdomain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class BroadcastResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.BroadcastResponse) */ {
 public:
  inline BroadcastResponse() : BroadcastResponse(nullptr) {}
  ~BroadcastResponse() override;
  explicit constexpr BroadcastResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastResponse(const BroadcastResponse& from);
  BroadcastResponse(BroadcastResponse&& from) noexcept
    : BroadcastResponse() {
    *this = ::std::move(from);
  }

  inline BroadcastResponse& operator=(const BroadcastResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastResponse& operator=(BroadcastResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastResponse* internal_default_instance() {
    return reinterpret_cast<const BroadcastResponse*>(
               &_BroadcastResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BroadcastResponse& a, BroadcastResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BroadcastResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.BroadcastResponse";
  }
  protected:
  explicit BroadcastResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxIDsFieldNumber = 1,
  };
  // repeated string txIDs = 1;
  int txids_size() const;
  private:
  int _internal_txids_size() const;
  public:
  void clear_txids();
  const std::string& txids(int index) const;
  std::string* mutable_txids(int index);
  void set_txids(int index, const std::string& value);
  void set_txids(int index, std::string&& value);
  void set_txids(int index, const char* value);
  void set_txids(int index, const char* value, size_t size);
  std::string* add_txids();
  void add_txids(const std::string& value);
  void add_txids(std::string&& value);
  void add_txids(const char* value);
  void add_txids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txids();
  private:
  const std::string& _internal_txids(int index) const;
  std::string* _internal_add_txids();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.BroadcastResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class ShutdownRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kaspawalletd.ShutdownRequest) */ {
 public:
  inline ShutdownRequest() : ShutdownRequest(nullptr) {}
  explicit constexpr ShutdownRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownRequest(const ShutdownRequest& from);
  ShutdownRequest(ShutdownRequest&& from) noexcept
    : ShutdownRequest() {
    *this = ::std::move(from);
  }

  inline ShutdownRequest& operator=(const ShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownRequest& operator=(ShutdownRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownRequest*>(
               &_ShutdownRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ShutdownRequest& a, ShutdownRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShutdownRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShutdownRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.ShutdownRequest";
  }
  protected:
  explicit ShutdownRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kaspawalletd.ShutdownRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class ShutdownResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kaspawalletd.ShutdownResponse) */ {
 public:
  inline ShutdownResponse() : ShutdownResponse(nullptr) {}
  explicit constexpr ShutdownResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownResponse(const ShutdownResponse& from);
  ShutdownResponse(ShutdownResponse&& from) noexcept
    : ShutdownResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownResponse& operator=(const ShutdownResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownResponse& operator=(ShutdownResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownResponse*>(
               &_ShutdownResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ShutdownResponse& a, ShutdownResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShutdownResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShutdownResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.ShutdownResponse";
  }
  protected:
  explicit ShutdownResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kaspawalletd.ShutdownResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class Outpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.Outpoint) */ {
 public:
  inline Outpoint() : Outpoint(nullptr) {}
  ~Outpoint() override;
  explicit constexpr Outpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Outpoint(const Outpoint& from);
  Outpoint(Outpoint&& from) noexcept
    : Outpoint() {
    *this = ::std::move(from);
  }

  inline Outpoint& operator=(const Outpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Outpoint& operator=(Outpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Outpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Outpoint* internal_default_instance() {
    return reinterpret_cast<const Outpoint*>(
               &_Outpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Outpoint& a, Outpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Outpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Outpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Outpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Outpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Outpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Outpoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Outpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.Outpoint";
  }
  protected:
  explicit Outpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string transactionId = 1;
  void clear_transactionid();
  const std::string& transactionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transactionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transactionid();
  PROTOBUF_NODISCARD std::string* release_transactionid();
  void set_allocated_transactionid(std::string* transactionid);
  private:
  const std::string& _internal_transactionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transactionid(const std::string& value);
  std::string* _internal_mutable_transactionid();
  public:

  // uint32 index = 2;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.Outpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transactionid_;
  uint32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class UtxosByAddressesEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.UtxosByAddressesEntry) */ {
 public:
  inline UtxosByAddressesEntry() : UtxosByAddressesEntry(nullptr) {}
  ~UtxosByAddressesEntry() override;
  explicit constexpr UtxosByAddressesEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UtxosByAddressesEntry(const UtxosByAddressesEntry& from);
  UtxosByAddressesEntry(UtxosByAddressesEntry&& from) noexcept
    : UtxosByAddressesEntry() {
    *this = ::std::move(from);
  }

  inline UtxosByAddressesEntry& operator=(const UtxosByAddressesEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline UtxosByAddressesEntry& operator=(UtxosByAddressesEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UtxosByAddressesEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const UtxosByAddressesEntry* internal_default_instance() {
    return reinterpret_cast<const UtxosByAddressesEntry*>(
               &_UtxosByAddressesEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UtxosByAddressesEntry& a, UtxosByAddressesEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(UtxosByAddressesEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UtxosByAddressesEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UtxosByAddressesEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UtxosByAddressesEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UtxosByAddressesEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UtxosByAddressesEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UtxosByAddressesEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.UtxosByAddressesEntry";
  }
  protected:
  explicit UtxosByAddressesEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kOutpointFieldNumber = 2,
    kUtxoEntryFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .kaspawalletd.Outpoint outpoint = 2;
  bool has_outpoint() const;
  private:
  bool _internal_has_outpoint() const;
  public:
  void clear_outpoint();
  const ::kaspawalletd::Outpoint& outpoint() const;
  PROTOBUF_NODISCARD ::kaspawalletd::Outpoint* release_outpoint();
  ::kaspawalletd::Outpoint* mutable_outpoint();
  void set_allocated_outpoint(::kaspawalletd::Outpoint* outpoint);
  private:
  const ::kaspawalletd::Outpoint& _internal_outpoint() const;
  ::kaspawalletd::Outpoint* _internal_mutable_outpoint();
  public:
  void unsafe_arena_set_allocated_outpoint(
      ::kaspawalletd::Outpoint* outpoint);
  ::kaspawalletd::Outpoint* unsafe_arena_release_outpoint();

  // .kaspawalletd.UtxoEntry utxoEntry = 3;
  bool has_utxoentry() const;
  private:
  bool _internal_has_utxoentry() const;
  public:
  void clear_utxoentry();
  const ::kaspawalletd::UtxoEntry& utxoentry() const;
  PROTOBUF_NODISCARD ::kaspawalletd::UtxoEntry* release_utxoentry();
  ::kaspawalletd::UtxoEntry* mutable_utxoentry();
  void set_allocated_utxoentry(::kaspawalletd::UtxoEntry* utxoentry);
  private:
  const ::kaspawalletd::UtxoEntry& _internal_utxoentry() const;
  ::kaspawalletd::UtxoEntry* _internal_mutable_utxoentry();
  public:
  void unsafe_arena_set_allocated_utxoentry(
      ::kaspawalletd::UtxoEntry* utxoentry);
  ::kaspawalletd::UtxoEntry* unsafe_arena_release_utxoentry();

  // @@protoc_insertion_point(class_scope:kaspawalletd.UtxosByAddressesEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::kaspawalletd::Outpoint* outpoint_;
  ::kaspawalletd::UtxoEntry* utxoentry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class ScriptPublicKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.ScriptPublicKey) */ {
 public:
  inline ScriptPublicKey() : ScriptPublicKey(nullptr) {}
  ~ScriptPublicKey() override;
  explicit constexpr ScriptPublicKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptPublicKey(const ScriptPublicKey& from);
  ScriptPublicKey(ScriptPublicKey&& from) noexcept
    : ScriptPublicKey() {
    *this = ::std::move(from);
  }

  inline ScriptPublicKey& operator=(const ScriptPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptPublicKey& operator=(ScriptPublicKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScriptPublicKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScriptPublicKey* internal_default_instance() {
    return reinterpret_cast<const ScriptPublicKey*>(
               &_ScriptPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ScriptPublicKey& a, ScriptPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ScriptPublicKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptPublicKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScriptPublicKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScriptPublicKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScriptPublicKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.ScriptPublicKey";
  }
  protected:
  explicit ScriptPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptPublicKeyFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // string scriptPublicKey = 2;
  void clear_scriptpublickey();
  const std::string& scriptpublickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scriptpublickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scriptpublickey();
  PROTOBUF_NODISCARD std::string* release_scriptpublickey();
  void set_allocated_scriptpublickey(std::string* scriptpublickey);
  private:
  const std::string& _internal_scriptpublickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scriptpublickey(const std::string& value);
  std::string* _internal_mutable_scriptpublickey();
  public:

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.ScriptPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scriptpublickey_;
  uint32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class UtxoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.UtxoEntry) */ {
 public:
  inline UtxoEntry() : UtxoEntry(nullptr) {}
  ~UtxoEntry() override;
  explicit constexpr UtxoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UtxoEntry(const UtxoEntry& from);
  UtxoEntry(UtxoEntry&& from) noexcept
    : UtxoEntry() {
    *this = ::std::move(from);
  }

  inline UtxoEntry& operator=(const UtxoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline UtxoEntry& operator=(UtxoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UtxoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const UtxoEntry* internal_default_instance() {
    return reinterpret_cast<const UtxoEntry*>(
               &_UtxoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UtxoEntry& a, UtxoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(UtxoEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UtxoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UtxoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UtxoEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UtxoEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UtxoEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UtxoEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.UtxoEntry";
  }
  protected:
  explicit UtxoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptPublicKeyFieldNumber = 2,
    kAmountFieldNumber = 1,
    kBlockDaaScoreFieldNumber = 3,
    kIsCoinbaseFieldNumber = 4,
  };
  // .kaspawalletd.ScriptPublicKey scriptPublicKey = 2;
  bool has_scriptpublickey() const;
  private:
  bool _internal_has_scriptpublickey() const;
  public:
  void clear_scriptpublickey();
  const ::kaspawalletd::ScriptPublicKey& scriptpublickey() const;
  PROTOBUF_NODISCARD ::kaspawalletd::ScriptPublicKey* release_scriptpublickey();
  ::kaspawalletd::ScriptPublicKey* mutable_scriptpublickey();
  void set_allocated_scriptpublickey(::kaspawalletd::ScriptPublicKey* scriptpublickey);
  private:
  const ::kaspawalletd::ScriptPublicKey& _internal_scriptpublickey() const;
  ::kaspawalletd::ScriptPublicKey* _internal_mutable_scriptpublickey();
  public:
  void unsafe_arena_set_allocated_scriptpublickey(
      ::kaspawalletd::ScriptPublicKey* scriptpublickey);
  ::kaspawalletd::ScriptPublicKey* unsafe_arena_release_scriptpublickey();

  // uint64 amount = 1;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 blockDaaScore = 3;
  void clear_blockdaascore();
  uint64_t blockdaascore() const;
  void set_blockdaascore(uint64_t value);
  private:
  uint64_t _internal_blockdaascore() const;
  void _internal_set_blockdaascore(uint64_t value);
  public:

  // bool isCoinbase = 4;
  void clear_iscoinbase();
  bool iscoinbase() const;
  void set_iscoinbase(bool value);
  private:
  bool _internal_iscoinbase() const;
  void _internal_set_iscoinbase(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.UtxoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kaspawalletd::ScriptPublicKey* scriptpublickey_;
  uint64_t amount_;
  uint64_t blockdaascore_;
  bool iscoinbase_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class GetExternalSpendableUTXOsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.GetExternalSpendableUTXOsRequest) */ {
 public:
  inline GetExternalSpendableUTXOsRequest() : GetExternalSpendableUTXOsRequest(nullptr) {}
  ~GetExternalSpendableUTXOsRequest() override;
  explicit constexpr GetExternalSpendableUTXOsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetExternalSpendableUTXOsRequest(const GetExternalSpendableUTXOsRequest& from);
  GetExternalSpendableUTXOsRequest(GetExternalSpendableUTXOsRequest&& from) noexcept
    : GetExternalSpendableUTXOsRequest() {
    *this = ::std::move(from);
  }

  inline GetExternalSpendableUTXOsRequest& operator=(const GetExternalSpendableUTXOsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetExternalSpendableUTXOsRequest& operator=(GetExternalSpendableUTXOsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetExternalSpendableUTXOsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetExternalSpendableUTXOsRequest* internal_default_instance() {
    return reinterpret_cast<const GetExternalSpendableUTXOsRequest*>(
               &_GetExternalSpendableUTXOsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetExternalSpendableUTXOsRequest& a, GetExternalSpendableUTXOsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetExternalSpendableUTXOsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetExternalSpendableUTXOsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetExternalSpendableUTXOsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetExternalSpendableUTXOsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetExternalSpendableUTXOsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetExternalSpendableUTXOsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExternalSpendableUTXOsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.GetExternalSpendableUTXOsRequest";
  }
  protected:
  explicit GetExternalSpendableUTXOsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.GetExternalSpendableUTXOsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class GetExternalSpendableUTXOsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.GetExternalSpendableUTXOsResponse) */ {
 public:
  inline GetExternalSpendableUTXOsResponse() : GetExternalSpendableUTXOsResponse(nullptr) {}
  ~GetExternalSpendableUTXOsResponse() override;
  explicit constexpr GetExternalSpendableUTXOsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetExternalSpendableUTXOsResponse(const GetExternalSpendableUTXOsResponse& from);
  GetExternalSpendableUTXOsResponse(GetExternalSpendableUTXOsResponse&& from) noexcept
    : GetExternalSpendableUTXOsResponse() {
    *this = ::std::move(from);
  }

  inline GetExternalSpendableUTXOsResponse& operator=(const GetExternalSpendableUTXOsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetExternalSpendableUTXOsResponse& operator=(GetExternalSpendableUTXOsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetExternalSpendableUTXOsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetExternalSpendableUTXOsResponse* internal_default_instance() {
    return reinterpret_cast<const GetExternalSpendableUTXOsResponse*>(
               &_GetExternalSpendableUTXOsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetExternalSpendableUTXOsResponse& a, GetExternalSpendableUTXOsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetExternalSpendableUTXOsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetExternalSpendableUTXOsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetExternalSpendableUTXOsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetExternalSpendableUTXOsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetExternalSpendableUTXOsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetExternalSpendableUTXOsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExternalSpendableUTXOsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.GetExternalSpendableUTXOsResponse";
  }
  protected:
  explicit GetExternalSpendableUTXOsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .kaspawalletd.UtxosByAddressesEntry Entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::kaspawalletd::UtxosByAddressesEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::UtxosByAddressesEntry >*
      mutable_entries();
  private:
  const ::kaspawalletd::UtxosByAddressesEntry& _internal_entries(int index) const;
  ::kaspawalletd::UtxosByAddressesEntry* _internal_add_entries();
  public:
  const ::kaspawalletd::UtxosByAddressesEntry& entries(int index) const;
  ::kaspawalletd::UtxosByAddressesEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::UtxosByAddressesEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:kaspawalletd.GetExternalSpendableUTXOsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::UtxosByAddressesEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class SendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.SendRequest) */ {
 public:
  inline SendRequest() : SendRequest(nullptr) {}
  ~SendRequest() override;
  explicit constexpr SendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendRequest(const SendRequest& from);
  SendRequest(SendRequest&& from) noexcept
    : SendRequest() {
    *this = ::std::move(from);
  }

  inline SendRequest& operator=(const SendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendRequest& operator=(SendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendRequest* internal_default_instance() {
    return reinterpret_cast<const SendRequest*>(
               &_SendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SendRequest& a, SendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.SendRequest";
  }
  protected:
  explicit SendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 4,
    kToAddressFieldNumber = 1,
    kPasswordFieldNumber = 3,
    kAmountFieldNumber = 2,
  };
  // repeated string from = 4;
  int from_size() const;
  private:
  int _internal_from_size() const;
  public:
  void clear_from();
  const std::string& from(int index) const;
  std::string* mutable_from(int index);
  void set_from(int index, const std::string& value);
  void set_from(int index, std::string&& value);
  void set_from(int index, const char* value);
  void set_from(int index, const char* value, size_t size);
  std::string* add_from();
  void add_from(const std::string& value);
  void add_from(std::string&& value);
  void add_from(const char* value);
  void add_from(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& from() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_from();
  private:
  const std::string& _internal_from(int index) const;
  std::string* _internal_add_from();
  public:

  // string toAddress = 1;
  void clear_toaddress();
  const std::string& toaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddress();
  PROTOBUF_NODISCARD std::string* release_toaddress();
  void set_allocated_toaddress(std::string* toaddress);
  private:
  const std::string& _internal_toaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddress(const std::string& value);
  std::string* _internal_mutable_toaddress();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // uint64 amount = 2;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.SendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  uint64_t amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class SendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.SendResponse) */ {
 public:
  inline SendResponse() : SendResponse(nullptr) {}
  ~SendResponse() override;
  explicit constexpr SendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendResponse(const SendResponse& from);
  SendResponse(SendResponse&& from) noexcept
    : SendResponse() {
    *this = ::std::move(from);
  }

  inline SendResponse& operator=(const SendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendResponse& operator=(SendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendResponse* internal_default_instance() {
    return reinterpret_cast<const SendResponse*>(
               &_SendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SendResponse& a, SendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.SendResponse";
  }
  protected:
  explicit SendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxIDsFieldNumber = 1,
  };
  // repeated string txIDs = 1;
  int txids_size() const;
  private:
  int _internal_txids_size() const;
  public:
  void clear_txids();
  const std::string& txids(int index) const;
  std::string* mutable_txids(int index);
  void set_txids(int index, const std::string& value);
  void set_txids(int index, std::string&& value);
  void set_txids(int index, const char* value);
  void set_txids(int index, const char* value, size_t size);
  std::string* add_txids();
  void add_txids(const std::string& value);
  void add_txids(std::string&& value);
  void add_txids(const char* value);
  void add_txids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txids();
  private:
  const std::string& _internal_txids(int index) const;
  std::string* _internal_add_txids();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.SendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class SignRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.SignRequest) */ {
 public:
  inline SignRequest() : SignRequest(nullptr) {}
  ~SignRequest() override;
  explicit constexpr SignRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignRequest(const SignRequest& from);
  SignRequest(SignRequest&& from) noexcept
    : SignRequest() {
    *this = ::std::move(from);
  }

  inline SignRequest& operator=(const SignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignRequest& operator=(SignRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignRequest* internal_default_instance() {
    return reinterpret_cast<const SignRequest*>(
               &_SignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SignRequest& a, SignRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.SignRequest";
  }
  protected:
  explicit SignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnsignedTransactionsFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // repeated bytes unsignedTransactions = 1;
  int unsignedtransactions_size() const;
  private:
  int _internal_unsignedtransactions_size() const;
  public:
  void clear_unsignedtransactions();
  const std::string& unsignedtransactions(int index) const;
  std::string* mutable_unsignedtransactions(int index);
  void set_unsignedtransactions(int index, const std::string& value);
  void set_unsignedtransactions(int index, std::string&& value);
  void set_unsignedtransactions(int index, const char* value);
  void set_unsignedtransactions(int index, const void* value, size_t size);
  std::string* add_unsignedtransactions();
  void add_unsignedtransactions(const std::string& value);
  void add_unsignedtransactions(std::string&& value);
  void add_unsignedtransactions(const char* value);
  void add_unsignedtransactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unsignedtransactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unsignedtransactions();
  private:
  const std::string& _internal_unsignedtransactions(int index) const;
  std::string* _internal_add_unsignedtransactions();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.SignRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unsignedtransactions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class SignResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.SignResponse) */ {
 public:
  inline SignResponse() : SignResponse(nullptr) {}
  ~SignResponse() override;
  explicit constexpr SignResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignResponse(const SignResponse& from);
  SignResponse(SignResponse&& from) noexcept
    : SignResponse() {
    *this = ::std::move(from);
  }

  inline SignResponse& operator=(const SignResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignResponse& operator=(SignResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignResponse* internal_default_instance() {
    return reinterpret_cast<const SignResponse*>(
               &_SignResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SignResponse& a, SignResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.SignResponse";
  }
  protected:
  explicit SignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedTransactionsFieldNumber = 1,
  };
  // repeated bytes signedTransactions = 1;
  int signedtransactions_size() const;
  private:
  int _internal_signedtransactions_size() const;
  public:
  void clear_signedtransactions();
  const std::string& signedtransactions(int index) const;
  std::string* mutable_signedtransactions(int index);
  void set_signedtransactions(int index, const std::string& value);
  void set_signedtransactions(int index, std::string&& value);
  void set_signedtransactions(int index, const char* value);
  void set_signedtransactions(int index, const void* value, size_t size);
  std::string* add_signedtransactions();
  void add_signedtransactions(const std::string& value);
  void add_signedtransactions(std::string&& value);
  void add_signedtransactions(const char* value);
  void add_signedtransactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signedtransactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signedtransactions();
  private:
  const std::string& _internal_signedtransactions(int index) const;
  std::string* _internal_add_signedtransactions();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.SignResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signedtransactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class IsValidAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.IsValidAddress) */ {
 public:
  inline IsValidAddress() : IsValidAddress(nullptr) {}
  ~IsValidAddress() override;
  explicit constexpr IsValidAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsValidAddress(const IsValidAddress& from);
  IsValidAddress(IsValidAddress&& from) noexcept
    : IsValidAddress() {
    *this = ::std::move(from);
  }

  inline IsValidAddress& operator=(const IsValidAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsValidAddress& operator=(IsValidAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsValidAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsValidAddress* internal_default_instance() {
    return reinterpret_cast<const IsValidAddress*>(
               &_IsValidAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(IsValidAddress& a, IsValidAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(IsValidAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsValidAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsValidAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsValidAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsValidAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IsValidAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsValidAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.IsValidAddress";
  }
  protected:
  explicit IsValidAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kErrorFieldNumber = 3,
    kIsValidFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string error = 3;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool isValid = 2;
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.IsValidAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool isvalid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class CheckIfAddressesAreValidRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.CheckIfAddressesAreValidRequest) */ {
 public:
  inline CheckIfAddressesAreValidRequest() : CheckIfAddressesAreValidRequest(nullptr) {}
  ~CheckIfAddressesAreValidRequest() override;
  explicit constexpr CheckIfAddressesAreValidRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckIfAddressesAreValidRequest(const CheckIfAddressesAreValidRequest& from);
  CheckIfAddressesAreValidRequest(CheckIfAddressesAreValidRequest&& from) noexcept
    : CheckIfAddressesAreValidRequest() {
    *this = ::std::move(from);
  }

  inline CheckIfAddressesAreValidRequest& operator=(const CheckIfAddressesAreValidRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckIfAddressesAreValidRequest& operator=(CheckIfAddressesAreValidRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckIfAddressesAreValidRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckIfAddressesAreValidRequest* internal_default_instance() {
    return reinterpret_cast<const CheckIfAddressesAreValidRequest*>(
               &_CheckIfAddressesAreValidRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CheckIfAddressesAreValidRequest& a, CheckIfAddressesAreValidRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckIfAddressesAreValidRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckIfAddressesAreValidRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckIfAddressesAreValidRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckIfAddressesAreValidRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckIfAddressesAreValidRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckIfAddressesAreValidRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckIfAddressesAreValidRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.CheckIfAddressesAreValidRequest";
  }
  protected:
  explicit CheckIfAddressesAreValidRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 1,
  };
  // repeated string addresses = 1;
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.CheckIfAddressesAreValidRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class CheckIfAddressesAreValidResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.CheckIfAddressesAreValidResponse) */ {
 public:
  inline CheckIfAddressesAreValidResponse() : CheckIfAddressesAreValidResponse(nullptr) {}
  ~CheckIfAddressesAreValidResponse() override;
  explicit constexpr CheckIfAddressesAreValidResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckIfAddressesAreValidResponse(const CheckIfAddressesAreValidResponse& from);
  CheckIfAddressesAreValidResponse(CheckIfAddressesAreValidResponse&& from) noexcept
    : CheckIfAddressesAreValidResponse() {
    *this = ::std::move(from);
  }

  inline CheckIfAddressesAreValidResponse& operator=(const CheckIfAddressesAreValidResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckIfAddressesAreValidResponse& operator=(CheckIfAddressesAreValidResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckIfAddressesAreValidResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckIfAddressesAreValidResponse* internal_default_instance() {
    return reinterpret_cast<const CheckIfAddressesAreValidResponse*>(
               &_CheckIfAddressesAreValidResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CheckIfAddressesAreValidResponse& a, CheckIfAddressesAreValidResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckIfAddressesAreValidResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckIfAddressesAreValidResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckIfAddressesAreValidResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckIfAddressesAreValidResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckIfAddressesAreValidResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckIfAddressesAreValidResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckIfAddressesAreValidResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.CheckIfAddressesAreValidResponse";
  }
  protected:
  explicit CheckIfAddressesAreValidResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAreValidAddressesFieldNumber = 1,
  };
  // repeated .kaspawalletd.IsValidAddress areValidAddresses = 1;
  int arevalidaddresses_size() const;
  private:
  int _internal_arevalidaddresses_size() const;
  public:
  void clear_arevalidaddresses();
  ::kaspawalletd::IsValidAddress* mutable_arevalidaddresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::IsValidAddress >*
      mutable_arevalidaddresses();
  private:
  const ::kaspawalletd::IsValidAddress& _internal_arevalidaddresses(int index) const;
  ::kaspawalletd::IsValidAddress* _internal_add_arevalidaddresses();
  public:
  const ::kaspawalletd::IsValidAddress& arevalidaddresses(int index) const;
  ::kaspawalletd::IsValidAddress* add_arevalidaddresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::IsValidAddress >&
      arevalidaddresses() const;

  // @@protoc_insertion_point(class_scope:kaspawalletd.CheckIfAddressesAreValidResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::IsValidAddress > arevalidaddresses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class CheckIfAddressIsValidRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.CheckIfAddressIsValidRequest) */ {
 public:
  inline CheckIfAddressIsValidRequest() : CheckIfAddressIsValidRequest(nullptr) {}
  ~CheckIfAddressIsValidRequest() override;
  explicit constexpr CheckIfAddressIsValidRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckIfAddressIsValidRequest(const CheckIfAddressIsValidRequest& from);
  CheckIfAddressIsValidRequest(CheckIfAddressIsValidRequest&& from) noexcept
    : CheckIfAddressIsValidRequest() {
    *this = ::std::move(from);
  }

  inline CheckIfAddressIsValidRequest& operator=(const CheckIfAddressIsValidRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckIfAddressIsValidRequest& operator=(CheckIfAddressIsValidRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckIfAddressIsValidRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckIfAddressIsValidRequest* internal_default_instance() {
    return reinterpret_cast<const CheckIfAddressIsValidRequest*>(
               &_CheckIfAddressIsValidRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CheckIfAddressIsValidRequest& a, CheckIfAddressIsValidRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckIfAddressIsValidRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckIfAddressIsValidRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckIfAddressIsValidRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckIfAddressIsValidRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckIfAddressIsValidRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckIfAddressIsValidRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckIfAddressIsValidRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.CheckIfAddressIsValidRequest";
  }
  protected:
  explicit CheckIfAddressIsValidRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.CheckIfAddressIsValidRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// -------------------------------------------------------------------

class CheckIfAddressIsValidResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaspawalletd.CheckIfAddressIsValidResponse) */ {
 public:
  inline CheckIfAddressIsValidResponse() : CheckIfAddressIsValidResponse(nullptr) {}
  ~CheckIfAddressIsValidResponse() override;
  explicit constexpr CheckIfAddressIsValidResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckIfAddressIsValidResponse(const CheckIfAddressIsValidResponse& from);
  CheckIfAddressIsValidResponse(CheckIfAddressIsValidResponse&& from) noexcept
    : CheckIfAddressIsValidResponse() {
    *this = ::std::move(from);
  }

  inline CheckIfAddressIsValidResponse& operator=(const CheckIfAddressIsValidResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckIfAddressIsValidResponse& operator=(CheckIfAddressIsValidResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckIfAddressIsValidResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckIfAddressIsValidResponse* internal_default_instance() {
    return reinterpret_cast<const CheckIfAddressIsValidResponse*>(
               &_CheckIfAddressIsValidResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CheckIfAddressIsValidResponse& a, CheckIfAddressIsValidResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckIfAddressIsValidResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckIfAddressIsValidResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckIfAddressIsValidResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckIfAddressIsValidResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckIfAddressIsValidResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckIfAddressIsValidResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckIfAddressIsValidResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaspawalletd.CheckIfAddressIsValidResponse";
  }
  protected:
  explicit CheckIfAddressIsValidResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kIsValidFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bool isValid = 2;
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kaspawalletd.CheckIfAddressIsValidResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  bool isvalid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaspawalletd_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetBalanceRequest

// -------------------------------------------------------------------

// GetBalanceResponse

// uint64 available = 1;
inline void GetBalanceResponse::clear_available() {
  available_ = uint64_t{0u};
}
inline uint64_t GetBalanceResponse::_internal_available() const {
  return available_;
}
inline uint64_t GetBalanceResponse::available() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.GetBalanceResponse.available)
  return _internal_available();
}
inline void GetBalanceResponse::_internal_set_available(uint64_t value) {
  
  available_ = value;
}
inline void GetBalanceResponse::set_available(uint64_t value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.GetBalanceResponse.available)
}

// uint64 pending = 2;
inline void GetBalanceResponse::clear_pending() {
  pending_ = uint64_t{0u};
}
inline uint64_t GetBalanceResponse::_internal_pending() const {
  return pending_;
}
inline uint64_t GetBalanceResponse::pending() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.GetBalanceResponse.pending)
  return _internal_pending();
}
inline void GetBalanceResponse::_internal_set_pending(uint64_t value) {
  
  pending_ = value;
}
inline void GetBalanceResponse::set_pending(uint64_t value) {
  _internal_set_pending(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.GetBalanceResponse.pending)
}

// repeated .kaspawalletd.AddressBalances addressBalances = 3;
inline int GetBalanceResponse::_internal_addressbalances_size() const {
  return addressbalances_.size();
}
inline int GetBalanceResponse::addressbalances_size() const {
  return _internal_addressbalances_size();
}
inline void GetBalanceResponse::clear_addressbalances() {
  addressbalances_.Clear();
}
inline ::kaspawalletd::AddressBalances* GetBalanceResponse::mutable_addressbalances(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.GetBalanceResponse.addressBalances)
  return addressbalances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::AddressBalances >*
GetBalanceResponse::mutable_addressbalances() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.GetBalanceResponse.addressBalances)
  return &addressbalances_;
}
inline const ::kaspawalletd::AddressBalances& GetBalanceResponse::_internal_addressbalances(int index) const {
  return addressbalances_.Get(index);
}
inline const ::kaspawalletd::AddressBalances& GetBalanceResponse::addressbalances(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.GetBalanceResponse.addressBalances)
  return _internal_addressbalances(index);
}
inline ::kaspawalletd::AddressBalances* GetBalanceResponse::_internal_add_addressbalances() {
  return addressbalances_.Add();
}
inline ::kaspawalletd::AddressBalances* GetBalanceResponse::add_addressbalances() {
  ::kaspawalletd::AddressBalances* _add = _internal_add_addressbalances();
  // @@protoc_insertion_point(field_add:kaspawalletd.GetBalanceResponse.addressBalances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::AddressBalances >&
GetBalanceResponse::addressbalances() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.GetBalanceResponse.addressBalances)
  return addressbalances_;
}

// -------------------------------------------------------------------

// AddressBalances

// string address = 1;
inline void AddressBalances::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AddressBalances::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.AddressBalances.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressBalances::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.AddressBalances.address)
}
inline std::string* AddressBalances::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.AddressBalances.address)
  return _s;
}
inline const std::string& AddressBalances::_internal_address() const {
  return address_.Get();
}
inline void AddressBalances::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddressBalances::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddressBalances::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.AddressBalances.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddressBalances::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.AddressBalances.address)
}

// uint64 available = 2;
inline void AddressBalances::clear_available() {
  available_ = uint64_t{0u};
}
inline uint64_t AddressBalances::_internal_available() const {
  return available_;
}
inline uint64_t AddressBalances::available() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.AddressBalances.available)
  return _internal_available();
}
inline void AddressBalances::_internal_set_available(uint64_t value) {
  
  available_ = value;
}
inline void AddressBalances::set_available(uint64_t value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.AddressBalances.available)
}

// uint64 pending = 3;
inline void AddressBalances::clear_pending() {
  pending_ = uint64_t{0u};
}
inline uint64_t AddressBalances::_internal_pending() const {
  return pending_;
}
inline uint64_t AddressBalances::pending() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.AddressBalances.pending)
  return _internal_pending();
}
inline void AddressBalances::_internal_set_pending(uint64_t value) {
  
  pending_ = value;
}
inline void AddressBalances::set_pending(uint64_t value) {
  _internal_set_pending(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.AddressBalances.pending)
}

// -------------------------------------------------------------------

// CreateUnsignedTransactionsRequest

// string address = 1;
inline void CreateUnsignedTransactionsRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& CreateUnsignedTransactionsRequest::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CreateUnsignedTransactionsRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUnsignedTransactionsRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.CreateUnsignedTransactionsRequest.address)
}
inline std::string* CreateUnsignedTransactionsRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CreateUnsignedTransactionsRequest.address)
  return _s;
}
inline const std::string& CreateUnsignedTransactionsRequest::_internal_address() const {
  return address_.Get();
}
inline void CreateUnsignedTransactionsRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateUnsignedTransactionsRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateUnsignedTransactionsRequest::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.CreateUnsignedTransactionsRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateUnsignedTransactionsRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.CreateUnsignedTransactionsRequest.address)
}

// uint64 amount = 2;
inline void CreateUnsignedTransactionsRequest::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t CreateUnsignedTransactionsRequest::_internal_amount() const {
  return amount_;
}
inline uint64_t CreateUnsignedTransactionsRequest::amount() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CreateUnsignedTransactionsRequest.amount)
  return _internal_amount();
}
inline void CreateUnsignedTransactionsRequest::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void CreateUnsignedTransactionsRequest::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.CreateUnsignedTransactionsRequest.amount)
}

// repeated string from = 3;
inline int CreateUnsignedTransactionsRequest::_internal_from_size() const {
  return from_.size();
}
inline int CreateUnsignedTransactionsRequest::from_size() const {
  return _internal_from_size();
}
inline void CreateUnsignedTransactionsRequest::clear_from() {
  from_.Clear();
}
inline std::string* CreateUnsignedTransactionsRequest::add_from() {
  std::string* _s = _internal_add_from();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.CreateUnsignedTransactionsRequest.from)
  return _s;
}
inline const std::string& CreateUnsignedTransactionsRequest::_internal_from(int index) const {
  return from_.Get(index);
}
inline const std::string& CreateUnsignedTransactionsRequest::from(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CreateUnsignedTransactionsRequest.from)
  return _internal_from(index);
}
inline std::string* CreateUnsignedTransactionsRequest::mutable_from(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CreateUnsignedTransactionsRequest.from)
  return from_.Mutable(index);
}
inline void CreateUnsignedTransactionsRequest::set_from(int index, const std::string& value) {
  from_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline void CreateUnsignedTransactionsRequest::set_from(int index, std::string&& value) {
  from_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline void CreateUnsignedTransactionsRequest::set_from(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  from_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline void CreateUnsignedTransactionsRequest::set_from(int index, const char* value, size_t size) {
  from_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline std::string* CreateUnsignedTransactionsRequest::_internal_add_from() {
  return from_.Add();
}
inline void CreateUnsignedTransactionsRequest::add_from(const std::string& value) {
  from_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline void CreateUnsignedTransactionsRequest::add_from(std::string&& value) {
  from_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline void CreateUnsignedTransactionsRequest::add_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  from_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline void CreateUnsignedTransactionsRequest::add_from(const char* value, size_t size) {
  from_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.CreateUnsignedTransactionsRequest.from)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateUnsignedTransactionsRequest::from() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.CreateUnsignedTransactionsRequest.from)
  return from_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateUnsignedTransactionsRequest::mutable_from() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.CreateUnsignedTransactionsRequest.from)
  return &from_;
}

// -------------------------------------------------------------------

// CreateUnsignedTransactionsResponse

// repeated bytes unsignedTransactions = 1;
inline int CreateUnsignedTransactionsResponse::_internal_unsignedtransactions_size() const {
  return unsignedtransactions_.size();
}
inline int CreateUnsignedTransactionsResponse::unsignedtransactions_size() const {
  return _internal_unsignedtransactions_size();
}
inline void CreateUnsignedTransactionsResponse::clear_unsignedtransactions() {
  unsignedtransactions_.Clear();
}
inline std::string* CreateUnsignedTransactionsResponse::add_unsignedtransactions() {
  std::string* _s = _internal_add_unsignedtransactions();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
  return _s;
}
inline const std::string& CreateUnsignedTransactionsResponse::_internal_unsignedtransactions(int index) const {
  return unsignedtransactions_.Get(index);
}
inline const std::string& CreateUnsignedTransactionsResponse::unsignedtransactions(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
  return _internal_unsignedtransactions(index);
}
inline std::string* CreateUnsignedTransactionsResponse::mutable_unsignedtransactions(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
  return unsignedtransactions_.Mutable(index);
}
inline void CreateUnsignedTransactionsResponse::set_unsignedtransactions(int index, const std::string& value) {
  unsignedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline void CreateUnsignedTransactionsResponse::set_unsignedtransactions(int index, std::string&& value) {
  unsignedtransactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline void CreateUnsignedTransactionsResponse::set_unsignedtransactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unsignedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline void CreateUnsignedTransactionsResponse::set_unsignedtransactions(int index, const void* value, size_t size) {
  unsignedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline std::string* CreateUnsignedTransactionsResponse::_internal_add_unsignedtransactions() {
  return unsignedtransactions_.Add();
}
inline void CreateUnsignedTransactionsResponse::add_unsignedtransactions(const std::string& value) {
  unsignedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline void CreateUnsignedTransactionsResponse::add_unsignedtransactions(std::string&& value) {
  unsignedtransactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline void CreateUnsignedTransactionsResponse::add_unsignedtransactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unsignedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline void CreateUnsignedTransactionsResponse::add_unsignedtransactions(const void* value, size_t size) {
  unsignedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateUnsignedTransactionsResponse::unsignedtransactions() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
  return unsignedtransactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateUnsignedTransactionsResponse::mutable_unsignedtransactions() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.CreateUnsignedTransactionsResponse.unsignedTransactions)
  return &unsignedtransactions_;
}

// -------------------------------------------------------------------

// ShowAddressesRequest

// -------------------------------------------------------------------

// ShowAddressesResponse

// repeated string address = 1;
inline int ShowAddressesResponse::_internal_address_size() const {
  return address_.size();
}
inline int ShowAddressesResponse::address_size() const {
  return _internal_address_size();
}
inline void ShowAddressesResponse::clear_address() {
  address_.Clear();
}
inline std::string* ShowAddressesResponse::add_address() {
  std::string* _s = _internal_add_address();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.ShowAddressesResponse.address)
  return _s;
}
inline const std::string& ShowAddressesResponse::_internal_address(int index) const {
  return address_.Get(index);
}
inline const std::string& ShowAddressesResponse::address(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.ShowAddressesResponse.address)
  return _internal_address(index);
}
inline std::string* ShowAddressesResponse::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.ShowAddressesResponse.address)
  return address_.Mutable(index);
}
inline void ShowAddressesResponse::set_address(int index, const std::string& value) {
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.ShowAddressesResponse.address)
}
inline void ShowAddressesResponse::set_address(int index, std::string&& value) {
  address_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.ShowAddressesResponse.address)
}
inline void ShowAddressesResponse::set_address(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.ShowAddressesResponse.address)
}
inline void ShowAddressesResponse::set_address(int index, const char* value, size_t size) {
  address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.ShowAddressesResponse.address)
}
inline std::string* ShowAddressesResponse::_internal_add_address() {
  return address_.Add();
}
inline void ShowAddressesResponse::add_address(const std::string& value) {
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.ShowAddressesResponse.address)
}
inline void ShowAddressesResponse::add_address(std::string&& value) {
  address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.ShowAddressesResponse.address)
}
inline void ShowAddressesResponse::add_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.ShowAddressesResponse.address)
}
inline void ShowAddressesResponse::add_address(const char* value, size_t size) {
  address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.ShowAddressesResponse.address)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShowAddressesResponse::address() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.ShowAddressesResponse.address)
  return address_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShowAddressesResponse::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.ShowAddressesResponse.address)
  return &address_;
}

// -------------------------------------------------------------------

// NewAddressRequest

// -------------------------------------------------------------------

// NewAddressResponse

// string address = 1;
inline void NewAddressResponse::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& NewAddressResponse::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.NewAddressResponse.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewAddressResponse::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.NewAddressResponse.address)
}
inline std::string* NewAddressResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.NewAddressResponse.address)
  return _s;
}
inline const std::string& NewAddressResponse::_internal_address() const {
  return address_.Get();
}
inline void NewAddressResponse::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NewAddressResponse::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NewAddressResponse::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.NewAddressResponse.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NewAddressResponse::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.NewAddressResponse.address)
}

// -------------------------------------------------------------------

// BroadcastRequest

// bool isDomain = 1;
inline void BroadcastRequest::clear_isdomain() {
  isdomain_ = false;
}
inline bool BroadcastRequest::_internal_isdomain() const {
  return isdomain_;
}
inline bool BroadcastRequest::isdomain() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.BroadcastRequest.isDomain)
  return _internal_isdomain();
}
inline void BroadcastRequest::_internal_set_isdomain(bool value) {
  
  isdomain_ = value;
}
inline void BroadcastRequest::set_isdomain(bool value) {
  _internal_set_isdomain(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.BroadcastRequest.isDomain)
}

// repeated bytes transactions = 2;
inline int BroadcastRequest::_internal_transactions_size() const {
  return transactions_.size();
}
inline int BroadcastRequest::transactions_size() const {
  return _internal_transactions_size();
}
inline void BroadcastRequest::clear_transactions() {
  transactions_.Clear();
}
inline std::string* BroadcastRequest::add_transactions() {
  std::string* _s = _internal_add_transactions();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.BroadcastRequest.transactions)
  return _s;
}
inline const std::string& BroadcastRequest::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const std::string& BroadcastRequest::transactions(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.BroadcastRequest.transactions)
  return _internal_transactions(index);
}
inline std::string* BroadcastRequest::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.BroadcastRequest.transactions)
  return transactions_.Mutable(index);
}
inline void BroadcastRequest::set_transactions(int index, const std::string& value) {
  transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.BroadcastRequest.transactions)
}
inline void BroadcastRequest::set_transactions(int index, std::string&& value) {
  transactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.BroadcastRequest.transactions)
}
inline void BroadcastRequest::set_transactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.BroadcastRequest.transactions)
}
inline void BroadcastRequest::set_transactions(int index, const void* value, size_t size) {
  transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.BroadcastRequest.transactions)
}
inline std::string* BroadcastRequest::_internal_add_transactions() {
  return transactions_.Add();
}
inline void BroadcastRequest::add_transactions(const std::string& value) {
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.BroadcastRequest.transactions)
}
inline void BroadcastRequest::add_transactions(std::string&& value) {
  transactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.BroadcastRequest.transactions)
}
inline void BroadcastRequest::add_transactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.BroadcastRequest.transactions)
}
inline void BroadcastRequest::add_transactions(const void* value, size_t size) {
  transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.BroadcastRequest.transactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BroadcastRequest::transactions() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.BroadcastRequest.transactions)
  return transactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BroadcastRequest::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.BroadcastRequest.transactions)
  return &transactions_;
}

// -------------------------------------------------------------------

// BroadcastResponse

// repeated string txIDs = 1;
inline int BroadcastResponse::_internal_txids_size() const {
  return txids_.size();
}
inline int BroadcastResponse::txids_size() const {
  return _internal_txids_size();
}
inline void BroadcastResponse::clear_txids() {
  txids_.Clear();
}
inline std::string* BroadcastResponse::add_txids() {
  std::string* _s = _internal_add_txids();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.BroadcastResponse.txIDs)
  return _s;
}
inline const std::string& BroadcastResponse::_internal_txids(int index) const {
  return txids_.Get(index);
}
inline const std::string& BroadcastResponse::txids(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.BroadcastResponse.txIDs)
  return _internal_txids(index);
}
inline std::string* BroadcastResponse::mutable_txids(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.BroadcastResponse.txIDs)
  return txids_.Mutable(index);
}
inline void BroadcastResponse::set_txids(int index, const std::string& value) {
  txids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.BroadcastResponse.txIDs)
}
inline void BroadcastResponse::set_txids(int index, std::string&& value) {
  txids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.BroadcastResponse.txIDs)
}
inline void BroadcastResponse::set_txids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.BroadcastResponse.txIDs)
}
inline void BroadcastResponse::set_txids(int index, const char* value, size_t size) {
  txids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.BroadcastResponse.txIDs)
}
inline std::string* BroadcastResponse::_internal_add_txids() {
  return txids_.Add();
}
inline void BroadcastResponse::add_txids(const std::string& value) {
  txids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.BroadcastResponse.txIDs)
}
inline void BroadcastResponse::add_txids(std::string&& value) {
  txids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.BroadcastResponse.txIDs)
}
inline void BroadcastResponse::add_txids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.BroadcastResponse.txIDs)
}
inline void BroadcastResponse::add_txids(const char* value, size_t size) {
  txids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.BroadcastResponse.txIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BroadcastResponse::txids() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.BroadcastResponse.txIDs)
  return txids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BroadcastResponse::mutable_txids() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.BroadcastResponse.txIDs)
  return &txids_;
}

// -------------------------------------------------------------------

// ShutdownRequest

// -------------------------------------------------------------------

// ShutdownResponse

// -------------------------------------------------------------------

// Outpoint

// string transactionId = 1;
inline void Outpoint::clear_transactionid() {
  transactionid_.ClearToEmpty();
}
inline const std::string& Outpoint::transactionid() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.Outpoint.transactionId)
  return _internal_transactionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Outpoint::set_transactionid(ArgT0&& arg0, ArgT... args) {
 
 transactionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.Outpoint.transactionId)
}
inline std::string* Outpoint::mutable_transactionid() {
  std::string* _s = _internal_mutable_transactionid();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.Outpoint.transactionId)
  return _s;
}
inline const std::string& Outpoint::_internal_transactionid() const {
  return transactionid_.Get();
}
inline void Outpoint::_internal_set_transactionid(const std::string& value) {
  
  transactionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Outpoint::_internal_mutable_transactionid() {
  
  return transactionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Outpoint::release_transactionid() {
  // @@protoc_insertion_point(field_release:kaspawalletd.Outpoint.transactionId)
  return transactionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Outpoint::set_allocated_transactionid(std::string* transactionid) {
  if (transactionid != nullptr) {
    
  } else {
    
  }
  transactionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transactionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transactionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transactionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.Outpoint.transactionId)
}

// uint32 index = 2;
inline void Outpoint::clear_index() {
  index_ = 0u;
}
inline uint32_t Outpoint::_internal_index() const {
  return index_;
}
inline uint32_t Outpoint::index() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.Outpoint.index)
  return _internal_index();
}
inline void Outpoint::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void Outpoint::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.Outpoint.index)
}

// -------------------------------------------------------------------

// UtxosByAddressesEntry

// string address = 1;
inline void UtxosByAddressesEntry::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& UtxosByAddressesEntry::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxosByAddressesEntry.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UtxosByAddressesEntry::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.UtxosByAddressesEntry.address)
}
inline std::string* UtxosByAddressesEntry::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.UtxosByAddressesEntry.address)
  return _s;
}
inline const std::string& UtxosByAddressesEntry::_internal_address() const {
  return address_.Get();
}
inline void UtxosByAddressesEntry::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UtxosByAddressesEntry::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UtxosByAddressesEntry::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.UtxosByAddressesEntry.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UtxosByAddressesEntry::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.UtxosByAddressesEntry.address)
}

// .kaspawalletd.Outpoint outpoint = 2;
inline bool UtxosByAddressesEntry::_internal_has_outpoint() const {
  return this != internal_default_instance() && outpoint_ != nullptr;
}
inline bool UtxosByAddressesEntry::has_outpoint() const {
  return _internal_has_outpoint();
}
inline void UtxosByAddressesEntry::clear_outpoint() {
  if (GetArenaForAllocation() == nullptr && outpoint_ != nullptr) {
    delete outpoint_;
  }
  outpoint_ = nullptr;
}
inline const ::kaspawalletd::Outpoint& UtxosByAddressesEntry::_internal_outpoint() const {
  const ::kaspawalletd::Outpoint* p = outpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::kaspawalletd::Outpoint&>(
      ::kaspawalletd::_Outpoint_default_instance_);
}
inline const ::kaspawalletd::Outpoint& UtxosByAddressesEntry::outpoint() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxosByAddressesEntry.outpoint)
  return _internal_outpoint();
}
inline void UtxosByAddressesEntry::unsafe_arena_set_allocated_outpoint(
    ::kaspawalletd::Outpoint* outpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outpoint_);
  }
  outpoint_ = outpoint;
  if (outpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaspawalletd.UtxosByAddressesEntry.outpoint)
}
inline ::kaspawalletd::Outpoint* UtxosByAddressesEntry::release_outpoint() {
  
  ::kaspawalletd::Outpoint* temp = outpoint_;
  outpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kaspawalletd::Outpoint* UtxosByAddressesEntry::unsafe_arena_release_outpoint() {
  // @@protoc_insertion_point(field_release:kaspawalletd.UtxosByAddressesEntry.outpoint)
  
  ::kaspawalletd::Outpoint* temp = outpoint_;
  outpoint_ = nullptr;
  return temp;
}
inline ::kaspawalletd::Outpoint* UtxosByAddressesEntry::_internal_mutable_outpoint() {
  
  if (outpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaspawalletd::Outpoint>(GetArenaForAllocation());
    outpoint_ = p;
  }
  return outpoint_;
}
inline ::kaspawalletd::Outpoint* UtxosByAddressesEntry::mutable_outpoint() {
  ::kaspawalletd::Outpoint* _msg = _internal_mutable_outpoint();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.UtxosByAddressesEntry.outpoint)
  return _msg;
}
inline void UtxosByAddressesEntry::set_allocated_outpoint(::kaspawalletd::Outpoint* outpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outpoint_;
  }
  if (outpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kaspawalletd::Outpoint>::GetOwningArena(outpoint);
    if (message_arena != submessage_arena) {
      outpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outpoint, submessage_arena);
    }
    
  } else {
    
  }
  outpoint_ = outpoint;
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.UtxosByAddressesEntry.outpoint)
}

// .kaspawalletd.UtxoEntry utxoEntry = 3;
inline bool UtxosByAddressesEntry::_internal_has_utxoentry() const {
  return this != internal_default_instance() && utxoentry_ != nullptr;
}
inline bool UtxosByAddressesEntry::has_utxoentry() const {
  return _internal_has_utxoentry();
}
inline void UtxosByAddressesEntry::clear_utxoentry() {
  if (GetArenaForAllocation() == nullptr && utxoentry_ != nullptr) {
    delete utxoentry_;
  }
  utxoentry_ = nullptr;
}
inline const ::kaspawalletd::UtxoEntry& UtxosByAddressesEntry::_internal_utxoentry() const {
  const ::kaspawalletd::UtxoEntry* p = utxoentry_;
  return p != nullptr ? *p : reinterpret_cast<const ::kaspawalletd::UtxoEntry&>(
      ::kaspawalletd::_UtxoEntry_default_instance_);
}
inline const ::kaspawalletd::UtxoEntry& UtxosByAddressesEntry::utxoentry() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxosByAddressesEntry.utxoEntry)
  return _internal_utxoentry();
}
inline void UtxosByAddressesEntry::unsafe_arena_set_allocated_utxoentry(
    ::kaspawalletd::UtxoEntry* utxoentry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(utxoentry_);
  }
  utxoentry_ = utxoentry;
  if (utxoentry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaspawalletd.UtxosByAddressesEntry.utxoEntry)
}
inline ::kaspawalletd::UtxoEntry* UtxosByAddressesEntry::release_utxoentry() {
  
  ::kaspawalletd::UtxoEntry* temp = utxoentry_;
  utxoentry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kaspawalletd::UtxoEntry* UtxosByAddressesEntry::unsafe_arena_release_utxoentry() {
  // @@protoc_insertion_point(field_release:kaspawalletd.UtxosByAddressesEntry.utxoEntry)
  
  ::kaspawalletd::UtxoEntry* temp = utxoentry_;
  utxoentry_ = nullptr;
  return temp;
}
inline ::kaspawalletd::UtxoEntry* UtxosByAddressesEntry::_internal_mutable_utxoentry() {
  
  if (utxoentry_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaspawalletd::UtxoEntry>(GetArenaForAllocation());
    utxoentry_ = p;
  }
  return utxoentry_;
}
inline ::kaspawalletd::UtxoEntry* UtxosByAddressesEntry::mutable_utxoentry() {
  ::kaspawalletd::UtxoEntry* _msg = _internal_mutable_utxoentry();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.UtxosByAddressesEntry.utxoEntry)
  return _msg;
}
inline void UtxosByAddressesEntry::set_allocated_utxoentry(::kaspawalletd::UtxoEntry* utxoentry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete utxoentry_;
  }
  if (utxoentry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kaspawalletd::UtxoEntry>::GetOwningArena(utxoentry);
    if (message_arena != submessage_arena) {
      utxoentry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, utxoentry, submessage_arena);
    }
    
  } else {
    
  }
  utxoentry_ = utxoentry;
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.UtxosByAddressesEntry.utxoEntry)
}

// -------------------------------------------------------------------

// ScriptPublicKey

// uint32 version = 1;
inline void ScriptPublicKey::clear_version() {
  version_ = 0u;
}
inline uint32_t ScriptPublicKey::_internal_version() const {
  return version_;
}
inline uint32_t ScriptPublicKey::version() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.ScriptPublicKey.version)
  return _internal_version();
}
inline void ScriptPublicKey::_internal_set_version(uint32_t value) {
  
  version_ = value;
}
inline void ScriptPublicKey::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.ScriptPublicKey.version)
}

// string scriptPublicKey = 2;
inline void ScriptPublicKey::clear_scriptpublickey() {
  scriptpublickey_.ClearToEmpty();
}
inline const std::string& ScriptPublicKey::scriptpublickey() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.ScriptPublicKey.scriptPublicKey)
  return _internal_scriptpublickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptPublicKey::set_scriptpublickey(ArgT0&& arg0, ArgT... args) {
 
 scriptpublickey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.ScriptPublicKey.scriptPublicKey)
}
inline std::string* ScriptPublicKey::mutable_scriptpublickey() {
  std::string* _s = _internal_mutable_scriptpublickey();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.ScriptPublicKey.scriptPublicKey)
  return _s;
}
inline const std::string& ScriptPublicKey::_internal_scriptpublickey() const {
  return scriptpublickey_.Get();
}
inline void ScriptPublicKey::_internal_set_scriptpublickey(const std::string& value) {
  
  scriptpublickey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ScriptPublicKey::_internal_mutable_scriptpublickey() {
  
  return scriptpublickey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ScriptPublicKey::release_scriptpublickey() {
  // @@protoc_insertion_point(field_release:kaspawalletd.ScriptPublicKey.scriptPublicKey)
  return scriptpublickey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ScriptPublicKey::set_allocated_scriptpublickey(std::string* scriptpublickey) {
  if (scriptpublickey != nullptr) {
    
  } else {
    
  }
  scriptpublickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scriptpublickey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scriptpublickey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scriptpublickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.ScriptPublicKey.scriptPublicKey)
}

// -------------------------------------------------------------------

// UtxoEntry

// uint64 amount = 1;
inline void UtxoEntry::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t UtxoEntry::_internal_amount() const {
  return amount_;
}
inline uint64_t UtxoEntry::amount() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxoEntry.amount)
  return _internal_amount();
}
inline void UtxoEntry::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void UtxoEntry::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.UtxoEntry.amount)
}

// .kaspawalletd.ScriptPublicKey scriptPublicKey = 2;
inline bool UtxoEntry::_internal_has_scriptpublickey() const {
  return this != internal_default_instance() && scriptpublickey_ != nullptr;
}
inline bool UtxoEntry::has_scriptpublickey() const {
  return _internal_has_scriptpublickey();
}
inline void UtxoEntry::clear_scriptpublickey() {
  if (GetArenaForAllocation() == nullptr && scriptpublickey_ != nullptr) {
    delete scriptpublickey_;
  }
  scriptpublickey_ = nullptr;
}
inline const ::kaspawalletd::ScriptPublicKey& UtxoEntry::_internal_scriptpublickey() const {
  const ::kaspawalletd::ScriptPublicKey* p = scriptpublickey_;
  return p != nullptr ? *p : reinterpret_cast<const ::kaspawalletd::ScriptPublicKey&>(
      ::kaspawalletd::_ScriptPublicKey_default_instance_);
}
inline const ::kaspawalletd::ScriptPublicKey& UtxoEntry::scriptpublickey() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxoEntry.scriptPublicKey)
  return _internal_scriptpublickey();
}
inline void UtxoEntry::unsafe_arena_set_allocated_scriptpublickey(
    ::kaspawalletd::ScriptPublicKey* scriptpublickey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scriptpublickey_);
  }
  scriptpublickey_ = scriptpublickey;
  if (scriptpublickey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaspawalletd.UtxoEntry.scriptPublicKey)
}
inline ::kaspawalletd::ScriptPublicKey* UtxoEntry::release_scriptpublickey() {
  
  ::kaspawalletd::ScriptPublicKey* temp = scriptpublickey_;
  scriptpublickey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kaspawalletd::ScriptPublicKey* UtxoEntry::unsafe_arena_release_scriptpublickey() {
  // @@protoc_insertion_point(field_release:kaspawalletd.UtxoEntry.scriptPublicKey)
  
  ::kaspawalletd::ScriptPublicKey* temp = scriptpublickey_;
  scriptpublickey_ = nullptr;
  return temp;
}
inline ::kaspawalletd::ScriptPublicKey* UtxoEntry::_internal_mutable_scriptpublickey() {
  
  if (scriptpublickey_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaspawalletd::ScriptPublicKey>(GetArenaForAllocation());
    scriptpublickey_ = p;
  }
  return scriptpublickey_;
}
inline ::kaspawalletd::ScriptPublicKey* UtxoEntry::mutable_scriptpublickey() {
  ::kaspawalletd::ScriptPublicKey* _msg = _internal_mutable_scriptpublickey();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.UtxoEntry.scriptPublicKey)
  return _msg;
}
inline void UtxoEntry::set_allocated_scriptpublickey(::kaspawalletd::ScriptPublicKey* scriptpublickey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete scriptpublickey_;
  }
  if (scriptpublickey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kaspawalletd::ScriptPublicKey>::GetOwningArena(scriptpublickey);
    if (message_arena != submessage_arena) {
      scriptpublickey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scriptpublickey, submessage_arena);
    }
    
  } else {
    
  }
  scriptpublickey_ = scriptpublickey;
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.UtxoEntry.scriptPublicKey)
}

// uint64 blockDaaScore = 3;
inline void UtxoEntry::clear_blockdaascore() {
  blockdaascore_ = uint64_t{0u};
}
inline uint64_t UtxoEntry::_internal_blockdaascore() const {
  return blockdaascore_;
}
inline uint64_t UtxoEntry::blockdaascore() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxoEntry.blockDaaScore)
  return _internal_blockdaascore();
}
inline void UtxoEntry::_internal_set_blockdaascore(uint64_t value) {
  
  blockdaascore_ = value;
}
inline void UtxoEntry::set_blockdaascore(uint64_t value) {
  _internal_set_blockdaascore(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.UtxoEntry.blockDaaScore)
}

// bool isCoinbase = 4;
inline void UtxoEntry::clear_iscoinbase() {
  iscoinbase_ = false;
}
inline bool UtxoEntry::_internal_iscoinbase() const {
  return iscoinbase_;
}
inline bool UtxoEntry::iscoinbase() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.UtxoEntry.isCoinbase)
  return _internal_iscoinbase();
}
inline void UtxoEntry::_internal_set_iscoinbase(bool value) {
  
  iscoinbase_ = value;
}
inline void UtxoEntry::set_iscoinbase(bool value) {
  _internal_set_iscoinbase(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.UtxoEntry.isCoinbase)
}

// -------------------------------------------------------------------

// GetExternalSpendableUTXOsRequest

// string address = 1;
inline void GetExternalSpendableUTXOsRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetExternalSpendableUTXOsRequest::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.GetExternalSpendableUTXOsRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetExternalSpendableUTXOsRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.GetExternalSpendableUTXOsRequest.address)
}
inline std::string* GetExternalSpendableUTXOsRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.GetExternalSpendableUTXOsRequest.address)
  return _s;
}
inline const std::string& GetExternalSpendableUTXOsRequest::_internal_address() const {
  return address_.Get();
}
inline void GetExternalSpendableUTXOsRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetExternalSpendableUTXOsRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetExternalSpendableUTXOsRequest::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.GetExternalSpendableUTXOsRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetExternalSpendableUTXOsRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.GetExternalSpendableUTXOsRequest.address)
}

// -------------------------------------------------------------------

// GetExternalSpendableUTXOsResponse

// repeated .kaspawalletd.UtxosByAddressesEntry Entries = 1;
inline int GetExternalSpendableUTXOsResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int GetExternalSpendableUTXOsResponse::entries_size() const {
  return _internal_entries_size();
}
inline void GetExternalSpendableUTXOsResponse::clear_entries() {
  entries_.Clear();
}
inline ::kaspawalletd::UtxosByAddressesEntry* GetExternalSpendableUTXOsResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.GetExternalSpendableUTXOsResponse.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::UtxosByAddressesEntry >*
GetExternalSpendableUTXOsResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.GetExternalSpendableUTXOsResponse.Entries)
  return &entries_;
}
inline const ::kaspawalletd::UtxosByAddressesEntry& GetExternalSpendableUTXOsResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::kaspawalletd::UtxosByAddressesEntry& GetExternalSpendableUTXOsResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.GetExternalSpendableUTXOsResponse.Entries)
  return _internal_entries(index);
}
inline ::kaspawalletd::UtxosByAddressesEntry* GetExternalSpendableUTXOsResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::kaspawalletd::UtxosByAddressesEntry* GetExternalSpendableUTXOsResponse::add_entries() {
  ::kaspawalletd::UtxosByAddressesEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:kaspawalletd.GetExternalSpendableUTXOsResponse.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::UtxosByAddressesEntry >&
GetExternalSpendableUTXOsResponse::entries() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.GetExternalSpendableUTXOsResponse.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// SendRequest

// string toAddress = 1;
inline void SendRequest::clear_toaddress() {
  toaddress_.ClearToEmpty();
}
inline const std::string& SendRequest::toaddress() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SendRequest.toAddress)
  return _internal_toaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendRequest::set_toaddress(ArgT0&& arg0, ArgT... args) {
 
 toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.SendRequest.toAddress)
}
inline std::string* SendRequest::mutable_toaddress() {
  std::string* _s = _internal_mutable_toaddress();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SendRequest.toAddress)
  return _s;
}
inline const std::string& SendRequest::_internal_toaddress() const {
  return toaddress_.Get();
}
inline void SendRequest::_internal_set_toaddress(const std::string& value) {
  
  toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendRequest::_internal_mutable_toaddress() {
  
  return toaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendRequest::release_toaddress() {
  // @@protoc_insertion_point(field_release:kaspawalletd.SendRequest.toAddress)
  return toaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendRequest::set_allocated_toaddress(std::string* toaddress) {
  if (toaddress != nullptr) {
    
  } else {
    
  }
  toaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), toaddress,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (toaddress_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    toaddress_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.SendRequest.toAddress)
}

// uint64 amount = 2;
inline void SendRequest::clear_amount() {
  amount_ = uint64_t{0u};
}
inline uint64_t SendRequest::_internal_amount() const {
  return amount_;
}
inline uint64_t SendRequest::amount() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SendRequest.amount)
  return _internal_amount();
}
inline void SendRequest::_internal_set_amount(uint64_t value) {
  
  amount_ = value;
}
inline void SendRequest::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.SendRequest.amount)
}

// string password = 3;
inline void SendRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& SendRequest::password() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SendRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.SendRequest.password)
}
inline std::string* SendRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SendRequest.password)
  return _s;
}
inline const std::string& SendRequest::_internal_password() const {
  return password_.Get();
}
inline void SendRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendRequest::release_password() {
  // @@protoc_insertion_point(field_release:kaspawalletd.SendRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.SendRequest.password)
}

// repeated string from = 4;
inline int SendRequest::_internal_from_size() const {
  return from_.size();
}
inline int SendRequest::from_size() const {
  return _internal_from_size();
}
inline void SendRequest::clear_from() {
  from_.Clear();
}
inline std::string* SendRequest::add_from() {
  std::string* _s = _internal_add_from();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.SendRequest.from)
  return _s;
}
inline const std::string& SendRequest::_internal_from(int index) const {
  return from_.Get(index);
}
inline const std::string& SendRequest::from(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SendRequest.from)
  return _internal_from(index);
}
inline std::string* SendRequest::mutable_from(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SendRequest.from)
  return from_.Mutable(index);
}
inline void SendRequest::set_from(int index, const std::string& value) {
  from_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.SendRequest.from)
}
inline void SendRequest::set_from(int index, std::string&& value) {
  from_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.SendRequest.from)
}
inline void SendRequest::set_from(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  from_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.SendRequest.from)
}
inline void SendRequest::set_from(int index, const char* value, size_t size) {
  from_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.SendRequest.from)
}
inline std::string* SendRequest::_internal_add_from() {
  return from_.Add();
}
inline void SendRequest::add_from(const std::string& value) {
  from_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.SendRequest.from)
}
inline void SendRequest::add_from(std::string&& value) {
  from_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.SendRequest.from)
}
inline void SendRequest::add_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  from_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.SendRequest.from)
}
inline void SendRequest::add_from(const char* value, size_t size) {
  from_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.SendRequest.from)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendRequest::from() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.SendRequest.from)
  return from_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendRequest::mutable_from() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.SendRequest.from)
  return &from_;
}

// -------------------------------------------------------------------

// SendResponse

// repeated string txIDs = 1;
inline int SendResponse::_internal_txids_size() const {
  return txids_.size();
}
inline int SendResponse::txids_size() const {
  return _internal_txids_size();
}
inline void SendResponse::clear_txids() {
  txids_.Clear();
}
inline std::string* SendResponse::add_txids() {
  std::string* _s = _internal_add_txids();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.SendResponse.txIDs)
  return _s;
}
inline const std::string& SendResponse::_internal_txids(int index) const {
  return txids_.Get(index);
}
inline const std::string& SendResponse::txids(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SendResponse.txIDs)
  return _internal_txids(index);
}
inline std::string* SendResponse::mutable_txids(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SendResponse.txIDs)
  return txids_.Mutable(index);
}
inline void SendResponse::set_txids(int index, const std::string& value) {
  txids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.SendResponse.txIDs)
}
inline void SendResponse::set_txids(int index, std::string&& value) {
  txids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.SendResponse.txIDs)
}
inline void SendResponse::set_txids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.SendResponse.txIDs)
}
inline void SendResponse::set_txids(int index, const char* value, size_t size) {
  txids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.SendResponse.txIDs)
}
inline std::string* SendResponse::_internal_add_txids() {
  return txids_.Add();
}
inline void SendResponse::add_txids(const std::string& value) {
  txids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.SendResponse.txIDs)
}
inline void SendResponse::add_txids(std::string&& value) {
  txids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.SendResponse.txIDs)
}
inline void SendResponse::add_txids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.SendResponse.txIDs)
}
inline void SendResponse::add_txids(const char* value, size_t size) {
  txids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.SendResponse.txIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendResponse::txids() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.SendResponse.txIDs)
  return txids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendResponse::mutable_txids() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.SendResponse.txIDs)
  return &txids_;
}

// -------------------------------------------------------------------

// SignRequest

// repeated bytes unsignedTransactions = 1;
inline int SignRequest::_internal_unsignedtransactions_size() const {
  return unsignedtransactions_.size();
}
inline int SignRequest::unsignedtransactions_size() const {
  return _internal_unsignedtransactions_size();
}
inline void SignRequest::clear_unsignedtransactions() {
  unsignedtransactions_.Clear();
}
inline std::string* SignRequest::add_unsignedtransactions() {
  std::string* _s = _internal_add_unsignedtransactions();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.SignRequest.unsignedTransactions)
  return _s;
}
inline const std::string& SignRequest::_internal_unsignedtransactions(int index) const {
  return unsignedtransactions_.Get(index);
}
inline const std::string& SignRequest::unsignedtransactions(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SignRequest.unsignedTransactions)
  return _internal_unsignedtransactions(index);
}
inline std::string* SignRequest::mutable_unsignedtransactions(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SignRequest.unsignedTransactions)
  return unsignedtransactions_.Mutable(index);
}
inline void SignRequest::set_unsignedtransactions(int index, const std::string& value) {
  unsignedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.SignRequest.unsignedTransactions)
}
inline void SignRequest::set_unsignedtransactions(int index, std::string&& value) {
  unsignedtransactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.SignRequest.unsignedTransactions)
}
inline void SignRequest::set_unsignedtransactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unsignedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.SignRequest.unsignedTransactions)
}
inline void SignRequest::set_unsignedtransactions(int index, const void* value, size_t size) {
  unsignedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.SignRequest.unsignedTransactions)
}
inline std::string* SignRequest::_internal_add_unsignedtransactions() {
  return unsignedtransactions_.Add();
}
inline void SignRequest::add_unsignedtransactions(const std::string& value) {
  unsignedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.SignRequest.unsignedTransactions)
}
inline void SignRequest::add_unsignedtransactions(std::string&& value) {
  unsignedtransactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.SignRequest.unsignedTransactions)
}
inline void SignRequest::add_unsignedtransactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unsignedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.SignRequest.unsignedTransactions)
}
inline void SignRequest::add_unsignedtransactions(const void* value, size_t size) {
  unsignedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.SignRequest.unsignedTransactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignRequest::unsignedtransactions() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.SignRequest.unsignedTransactions)
  return unsignedtransactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignRequest::mutable_unsignedtransactions() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.SignRequest.unsignedTransactions)
  return &unsignedtransactions_;
}

// string password = 2;
inline void SignRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& SignRequest::password() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SignRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.SignRequest.password)
}
inline std::string* SignRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SignRequest.password)
  return _s;
}
inline const std::string& SignRequest::_internal_password() const {
  return password_.Get();
}
inline void SignRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignRequest::release_password() {
  // @@protoc_insertion_point(field_release:kaspawalletd.SignRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.SignRequest.password)
}

// -------------------------------------------------------------------

// SignResponse

// repeated bytes signedTransactions = 1;
inline int SignResponse::_internal_signedtransactions_size() const {
  return signedtransactions_.size();
}
inline int SignResponse::signedtransactions_size() const {
  return _internal_signedtransactions_size();
}
inline void SignResponse::clear_signedtransactions() {
  signedtransactions_.Clear();
}
inline std::string* SignResponse::add_signedtransactions() {
  std::string* _s = _internal_add_signedtransactions();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.SignResponse.signedTransactions)
  return _s;
}
inline const std::string& SignResponse::_internal_signedtransactions(int index) const {
  return signedtransactions_.Get(index);
}
inline const std::string& SignResponse::signedtransactions(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.SignResponse.signedTransactions)
  return _internal_signedtransactions(index);
}
inline std::string* SignResponse::mutable_signedtransactions(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.SignResponse.signedTransactions)
  return signedtransactions_.Mutable(index);
}
inline void SignResponse::set_signedtransactions(int index, const std::string& value) {
  signedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.SignResponse.signedTransactions)
}
inline void SignResponse::set_signedtransactions(int index, std::string&& value) {
  signedtransactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.SignResponse.signedTransactions)
}
inline void SignResponse::set_signedtransactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.SignResponse.signedTransactions)
}
inline void SignResponse::set_signedtransactions(int index, const void* value, size_t size) {
  signedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.SignResponse.signedTransactions)
}
inline std::string* SignResponse::_internal_add_signedtransactions() {
  return signedtransactions_.Add();
}
inline void SignResponse::add_signedtransactions(const std::string& value) {
  signedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.SignResponse.signedTransactions)
}
inline void SignResponse::add_signedtransactions(std::string&& value) {
  signedtransactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.SignResponse.signedTransactions)
}
inline void SignResponse::add_signedtransactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.SignResponse.signedTransactions)
}
inline void SignResponse::add_signedtransactions(const void* value, size_t size) {
  signedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.SignResponse.signedTransactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignResponse::signedtransactions() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.SignResponse.signedTransactions)
  return signedtransactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignResponse::mutable_signedtransactions() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.SignResponse.signedTransactions)
  return &signedtransactions_;
}

// -------------------------------------------------------------------

// IsValidAddress

// string address = 1;
inline void IsValidAddress::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& IsValidAddress::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.IsValidAddress.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsValidAddress::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.IsValidAddress.address)
}
inline std::string* IsValidAddress::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.IsValidAddress.address)
  return _s;
}
inline const std::string& IsValidAddress::_internal_address() const {
  return address_.Get();
}
inline void IsValidAddress::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IsValidAddress::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IsValidAddress::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.IsValidAddress.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IsValidAddress::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.IsValidAddress.address)
}

// bool isValid = 2;
inline void IsValidAddress::clear_isvalid() {
  isvalid_ = false;
}
inline bool IsValidAddress::_internal_isvalid() const {
  return isvalid_;
}
inline bool IsValidAddress::isvalid() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.IsValidAddress.isValid)
  return _internal_isvalid();
}
inline void IsValidAddress::_internal_set_isvalid(bool value) {
  
  isvalid_ = value;
}
inline void IsValidAddress::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.IsValidAddress.isValid)
}

// string error = 3;
inline void IsValidAddress::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& IsValidAddress::error() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.IsValidAddress.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsValidAddress::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.IsValidAddress.error)
}
inline std::string* IsValidAddress::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.IsValidAddress.error)
  return _s;
}
inline const std::string& IsValidAddress::_internal_error() const {
  return error_.Get();
}
inline void IsValidAddress::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IsValidAddress::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IsValidAddress::release_error() {
  // @@protoc_insertion_point(field_release:kaspawalletd.IsValidAddress.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IsValidAddress::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.IsValidAddress.error)
}

// -------------------------------------------------------------------

// CheckIfAddressesAreValidRequest

// repeated string addresses = 1;
inline int CheckIfAddressesAreValidRequest::_internal_addresses_size() const {
  return addresses_.size();
}
inline int CheckIfAddressesAreValidRequest::addresses_size() const {
  return _internal_addresses_size();
}
inline void CheckIfAddressesAreValidRequest::clear_addresses() {
  addresses_.Clear();
}
inline std::string* CheckIfAddressesAreValidRequest::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
  return _s;
}
inline const std::string& CheckIfAddressesAreValidRequest::_internal_addresses(int index) const {
  return addresses_.Get(index);
}
inline const std::string& CheckIfAddressesAreValidRequest::addresses(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
  return _internal_addresses(index);
}
inline std::string* CheckIfAddressesAreValidRequest::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
  return addresses_.Mutable(index);
}
inline void CheckIfAddressesAreValidRequest::set_addresses(int index, const std::string& value) {
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline void CheckIfAddressesAreValidRequest::set_addresses(int index, std::string&& value) {
  addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline void CheckIfAddressesAreValidRequest::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline void CheckIfAddressesAreValidRequest::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline std::string* CheckIfAddressesAreValidRequest::_internal_add_addresses() {
  return addresses_.Add();
}
inline void CheckIfAddressesAreValidRequest::add_addresses(const std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline void CheckIfAddressesAreValidRequest::add_addresses(std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline void CheckIfAddressesAreValidRequest::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline void CheckIfAddressesAreValidRequest::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CheckIfAddressesAreValidRequest::addresses() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
  return addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CheckIfAddressesAreValidRequest::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.CheckIfAddressesAreValidRequest.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// CheckIfAddressesAreValidResponse

// repeated .kaspawalletd.IsValidAddress areValidAddresses = 1;
inline int CheckIfAddressesAreValidResponse::_internal_arevalidaddresses_size() const {
  return arevalidaddresses_.size();
}
inline int CheckIfAddressesAreValidResponse::arevalidaddresses_size() const {
  return _internal_arevalidaddresses_size();
}
inline void CheckIfAddressesAreValidResponse::clear_arevalidaddresses() {
  arevalidaddresses_.Clear();
}
inline ::kaspawalletd::IsValidAddress* CheckIfAddressesAreValidResponse::mutable_arevalidaddresses(int index) {
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CheckIfAddressesAreValidResponse.areValidAddresses)
  return arevalidaddresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::IsValidAddress >*
CheckIfAddressesAreValidResponse::mutable_arevalidaddresses() {
  // @@protoc_insertion_point(field_mutable_list:kaspawalletd.CheckIfAddressesAreValidResponse.areValidAddresses)
  return &arevalidaddresses_;
}
inline const ::kaspawalletd::IsValidAddress& CheckIfAddressesAreValidResponse::_internal_arevalidaddresses(int index) const {
  return arevalidaddresses_.Get(index);
}
inline const ::kaspawalletd::IsValidAddress& CheckIfAddressesAreValidResponse::arevalidaddresses(int index) const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CheckIfAddressesAreValidResponse.areValidAddresses)
  return _internal_arevalidaddresses(index);
}
inline ::kaspawalletd::IsValidAddress* CheckIfAddressesAreValidResponse::_internal_add_arevalidaddresses() {
  return arevalidaddresses_.Add();
}
inline ::kaspawalletd::IsValidAddress* CheckIfAddressesAreValidResponse::add_arevalidaddresses() {
  ::kaspawalletd::IsValidAddress* _add = _internal_add_arevalidaddresses();
  // @@protoc_insertion_point(field_add:kaspawalletd.CheckIfAddressesAreValidResponse.areValidAddresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaspawalletd::IsValidAddress >&
CheckIfAddressesAreValidResponse::arevalidaddresses() const {
  // @@protoc_insertion_point(field_list:kaspawalletd.CheckIfAddressesAreValidResponse.areValidAddresses)
  return arevalidaddresses_;
}

// -------------------------------------------------------------------

// CheckIfAddressIsValidRequest

// string address = 1;
inline void CheckIfAddressIsValidRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& CheckIfAddressIsValidRequest::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CheckIfAddressIsValidRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckIfAddressIsValidRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.CheckIfAddressIsValidRequest.address)
}
inline std::string* CheckIfAddressIsValidRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CheckIfAddressIsValidRequest.address)
  return _s;
}
inline const std::string& CheckIfAddressIsValidRequest::_internal_address() const {
  return address_.Get();
}
inline void CheckIfAddressIsValidRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckIfAddressIsValidRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckIfAddressIsValidRequest::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.CheckIfAddressIsValidRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckIfAddressIsValidRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.CheckIfAddressIsValidRequest.address)
}

// -------------------------------------------------------------------

// CheckIfAddressIsValidResponse

// string address = 1;
inline void CheckIfAddressIsValidResponse::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& CheckIfAddressIsValidResponse::address() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CheckIfAddressIsValidResponse.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckIfAddressIsValidResponse::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaspawalletd.CheckIfAddressIsValidResponse.address)
}
inline std::string* CheckIfAddressIsValidResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:kaspawalletd.CheckIfAddressIsValidResponse.address)
  return _s;
}
inline const std::string& CheckIfAddressIsValidResponse::_internal_address() const {
  return address_.Get();
}
inline void CheckIfAddressIsValidResponse::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckIfAddressIsValidResponse::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckIfAddressIsValidResponse::release_address() {
  // @@protoc_insertion_point(field_release:kaspawalletd.CheckIfAddressIsValidResponse.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckIfAddressIsValidResponse::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaspawalletd.CheckIfAddressIsValidResponse.address)
}

// bool isValid = 2;
inline void CheckIfAddressIsValidResponse::clear_isvalid() {
  isvalid_ = false;
}
inline bool CheckIfAddressIsValidResponse::_internal_isvalid() const {
  return isvalid_;
}
inline bool CheckIfAddressIsValidResponse::isvalid() const {
  // @@protoc_insertion_point(field_get:kaspawalletd.CheckIfAddressIsValidResponse.isValid)
  return _internal_isvalid();
}
inline void CheckIfAddressIsValidResponse::_internal_set_isvalid(bool value) {
  
  isvalid_ = value;
}
inline void CheckIfAddressIsValidResponse::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:kaspawalletd.CheckIfAddressIsValidResponse.isValid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kaspawalletd

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kaspawalletd_2eproto
